# [NOIP2008 普及组] 传球游戏

## 题目描述

上体育课的时候，小蛮的老师经常带着同学们一起做游戏。这次，老师带着同学们一起做传球游戏。

游戏规则是这样的：$n$个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时，拿着球没有传出去的那个同学就是败者，要给大家表演一个节目。

聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了$m$次以后，又回到小蛮手里。两种传球方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有三个同学$1$号、$2$号、$3$号，并假设小蛮为$1$号，球传了$3$次回到小蛮手里的方式有$1$->$2$->$3$->$1$和$1$->$3$->$2$->$1$，共$2$种。

## 输入格式

一行，有两个用空格隔开的整数$n,m(3 \le n \le 30,1 \le m \le 30)$。

## 输出格式

$1$个整数，表示符合题意的方法数。

## 样例 #1

### 样例输入 #1

```
3 3
```

### 样例输出 #1

```
2
```

## 提示

40%的数据满足：$3 \le n \le 30,1 \le m \le 20$

100%的数据满足：$3 \le n \le 30,1 \le m \le 30$

2008普及组第三题

## key

dp

## my-accode

~~~c++
#include<bits/stdc++.h>
#include<iostream>
using namespace std;
#define MAXN 10010
#define ll long long int
/**
 * p1057 传球游戏
*/
int main(){
     int m,n;
     cin>>n>>m;
     int dp[33][33];
     memset(dp,0,sizeof(dp));
     dp[0][1] = 1;
    for (int i = 1; i <= m; i ++){
        for (int j = 1; j <= n; j ++) {
            int a = j - 1;
            int b = j + 1;
            if (a == 0) {
                a = n;
            }
            if (b == n + 1){
                 b = 1;
            }
            dp[i][j] = dp[i - 1][a] + dp[i - 1][b];
        }
    }
        
     cout<<dp[m][1];

	return 0;
} 
~~~



## 题解1

>## 不用特殊处理第1个和第n个，用一点小技巧
>
>。。。。大家先来看下代码
>
>```c++
>#include<bits/stdc++.h>
>using namespace std;
>int n,m,f[50][50];                  //1
>int main()
>{
>	cin>>n>>m;f[0][0]=1;            //2
>	for(int i=0;i<m;i++)
>	for(int j=0;j<n;j++)
>	if(f[i][j])                     //3
>	f[i+1][(j-1+n)%n]+=f[i][j],     //4
>	f[i+1][(j+1)%n]+=f[i][j];     //5
>	cout<<f[m][0];
>    return 0;
>}
>```
>
>- 1：f[n][m]中，n为传了几次，m为传到第几个人。
>- 2：有人要问为什么不是f[0][1]=1,因为后面取模时，方便计算。 但为什么不对(n+1)取模呢？因为第1个左传虽然是n，但是第n个右传就是0了。又有人要问了，我往左传对(n+1)取模，往右传对n取模不就行了吗？但第n-1个往右传呢？
>- 3：若上次传球能传到，那么就向左传、向右传。
>- 4：左传，这里+n再%n就解决环的问题，后面是‘，’可以并列语句，少大括号。
>- 5：右传，这里%n同样解决环的问题。
>- end：输出f[m][0]，传m次回到原来位置
>
>



## 题解2

对于这道题，一开始我是想找传球次数的递推，但是这样会忽视总人数对传球次数的限制，所以用二维数组来递推。可设一个dp[ i][ j]表示第j次传递给第i个人的方案，那么显然可以有dp[ i][ j]=dp[ i-1][ j-1]+dp[ i+1][ j-1]，那么根据递推算出dp[1][m]即可。 但是，人的占位会影响递推式，要预处理第1个人和第n个人。

```c
 dp[1][0]=1;
 for(int j=1;j<=m;j++)
    {
        dp[1][j]=dp[2][j-1]+dp[n][j-1];
        for(int i=2;i<=n-1;i++)
        {
            dp[i][j]=dp[i-1][j-1]+dp[i+1][j-1];
        }
        dp[n][j]=dp[n-1][j-1]+dp[1][j-1];
    }
```

这就是递推式，很多萌新(我也是)在初学递推的时候困难在于递推关系的确定和怎样用合适的语言描述递推式。那么首先要确定递推的起点，就这题而言，起点就是第一个人不传球，也就是dp[1][0]=1。那么再写出合适的循环，变量有2个，n和m，所以显然要双重循环，但到底是谁先循环呢？由于要计算dp[1][m],在m变量的循环中，每一个人要被历遍，所以是先m变量的大循环，再n变量的小循环。同时也要注意，预处理第1个人和第n个人。这些都考虑清楚，这题也就出来了。