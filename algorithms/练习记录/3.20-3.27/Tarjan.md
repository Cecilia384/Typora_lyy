## [**Tarjan算法**](https://segmentfault.com/a/1190000039149539)

图的一些基本概念：

- 关联（incident）：点为边的端点;
- 邻接（adjacent）：点与点关联同一条边，或边与边关联同一顶点；
- 子图：图G'的点和边都是图G的子集，则G'为G的子图;
- 道路：从点v到点u的路径；
- 简单道路：没有重复边的道路；
- 回路：起点与终点相同的道路；
- 简单回路：没有重复边的回路；
- 连通：两顶点间有道路；
- **强连通**：有向图u→v与v→u都有道路||（在有向图G<V,E>中，对于点集V'∈V, 点集中的任意两点都可达，则称V'为强连通。）
- 连通图：任意两顶点间都有道路（若有向图除去方向后连通，则称有向图连通）；
- 简单图：没有重复边和自环的图；
- 完全图：任意两顶点间有一条边到达的简单图（有向完全图与无向完全图）；
- 强连通（strongly connected）: 在有向图G 中，如果两个顶点间至少存在一条路径，称两个顶点强连通（strongly connected）；
- 强连通图: 如果有向图G 的每两个顶点都强连通，称G 是一个强连通图；
- **强连通分量**(strongly connected components): 非强连通图有向图的极大强连通子图，称为强连通分量(strongly connected components)。(孤立的一个点也是一个强连通分量)



**求强连通分量**就是我们今天要解决的问题，根据强连通分量定义，用双向遍历取交集的方法求强连通分量，时间复杂度为 $O（N^2+M）$. 而Tarjan或Kosaraju算法, 两者的时间复杂度都是 $O（N+M）$。



[csdn--强连通分量及缩点tarjan算法解析](https://blog.csdn.net/acmmmm/article/details/16361033)



​		**Tarjan 算法**是基于对图**深度优先搜索**的算法，每个强连通分量为搜索树中的一棵子树。搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量



- **DFN[i]**   ==表示 节点u 搜索的次序编号(时间戳)== || 遍历到 i 点时是第几次dfs

- **Low[u]**  ==为u 或 u的子树能够追溯到的最早的栈中节点的次序号== ||  以u点为父节点的 子树 能连接到 [栈中] 最上端的点 的DFN值(换句话说，是最小的DFN，因为最上端的DFN是最小的嘛）

- 算法：

1. 当首次搜索到点u时DFN[u]=LOW[u]=time;
2. 每当搜索到一个点，把该点压入栈顶;
3. 当u和v有边相连时:

​	1）如果v不在栈中（树枝边），DFS(v)，并且LOW[u] = min{LOW(u),LOW(v)};

​	2）如果v在栈中（前向边/后向边），此时LOW[u] = min{LOW[u],DFN[v]}

1. 当DFN[u]=LOW[u]时，将它以及在它之上的元素弹出栈，此时，弹出栈的结点构成一个强连通分量;
2. 继续搜索，知道图被遍历完毕。

由于在这个过程中每个点只被访问一次，每条边也只被访问一次，所以Tarjan算法的时间复杂度是O(n+m).





[acwing例题题解](https://www.acwing.com/solution/content/20678/)

