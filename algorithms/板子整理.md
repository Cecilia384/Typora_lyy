# ACM模板



## 目录

[TOC]



## 输入输出优化

### 快读

```c++
template <typename T> inline void read(T& t) {
    int f = 0, c = getchar(); t = 0; 
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) t = t * 10 + c - 48, c = getchar();
    if (f) t = -t;
}

template <typename T> void print(T x) {
    if (x < 0) x = -x, putchar('-');
    if (x > 9) print(x / 10);
    putchar(x % 10 + 48);
} 
```



### cin关同步

```c++
	ios::sync_with_stdio(false) ;
	cin.tie(0);
```



# 一、STL------

## vector


```c++
    size()  返回元素个数
    empty()  返回是否为空
    clear()  清空
    front()/back()
    push_back()/pop_back()
    begin()/end()
    []
    支持比较运算，按字典序
```



## pair

```c++
pair<int, int>
    first, 第一个元素
    second, 第二个元素
    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）
```



## string

```c++
string
    size()/length()  返回字符串长度
    empty()
    clear()
    substr(起始下标，(子串长度))  返回子串
    c_str()  返回字符串所在字符数组的起始地址
```



## queue

```c++
    size()
    empty()
    push()  向队尾插入一个元素
    front()  返回队头元素
    back()  返回队尾元素
    pop()  弹出队头元素
```



## priority_queue

```c++
    push()  插入一个元素
    top()  返回堆顶元素
    pop()  弹出堆顶元素
    定义成小根堆的方式：priority_queue<int, vector<int>, greater<int>> q;
```



## stack

```c++
    size()
    empty()
    push()  向栈顶插入一个元素
    top()  返回栈顶元素
    pop()  弹出栈顶元素
```



## deque

```c++
    size()
    empty()
    clear()
    front()/back()
    push_back()/pop_back()
    push_front()/pop_front()
    begin()/end()
    []
```



## set, map类

（multiset, multimap,unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表)

```c++
    size()
    empty()
    clear()
    begin()/end()
    ++, -- 返回前驱和后继，时间复杂度 O(logn)

    set/multiset
        insert()  插入一个数
        find()  查找一个数
        count()  返回某一个数的个数
        erase()
            (1) 输入是一个数x，删除所有x   O(k + logn)
            (2) 输入一个迭代器，删除这个迭代器
        lower_bound()/upper_bound()
            lower_bound(x)  返回大于等于x的最小的数的迭代器
            upper_bound(x)  返回大于x的最小的数的迭代器
        
    map/multimap
        insert()  插入的数是一个pair
        erase()  输入的参数是pair或者迭代器
        find()
        []  注意multimap不支持此操作。 时间复杂度是 O(logn)
        lower_bound()/upper_bound()
        
unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表
    和上面类似，增删改查的时间复杂度是 O(1)
    不支持 lower_bound()/upper_bound()， 迭代器的++，--

```



## bitset

```c++
    bitset<10000> s;
    ~, &, |, ^
    >>, <<
    ==, !=
    []

    count()  返回有多少个1

    any()  判断是否至少有一个1
    none()  判断是否全为0

    set()  把所有位置成1
    set(k, v)  将第k位变成v
    reset()  把所有位变成0
    flip()  等价于~
    flip(k) 把第k位取反
```



## 位运算

```c++
int __builtin_ffs(int x) 返回x的二进制末尾最后一个1的位置,位置的编号从1开始(最低位编号为1)。当x为0时返回0。
    
int __builtin_clz(unsigned int x) 返回x的二进制的前导0的个数。当x为0时，结果未定义。
    
int __builtin_ctz(unsigned int x) 返回x的二进制末尾连续0的个数。当x为0时，结果未定义。
    
int __builtin_clrsb(int x) 当 x 的符号位为0时返回x的二进制的前导0的个数减一，否则返回x的二进制的前导1的个数减一。
    
int __builtin_popcount(unsigned int x) 返回x的二进制中1的个数。
    
int __builtin_parity(unsigned int x) 判断x的二进制中1的个数的奇偶性。
```



# 二、字符串

## 1、Trie

```c++
int cnt,nxt[字符串总长度][字符串种类数],t[字符串总长度];
string s;
    
void insert(string s){
	int p=0,l=s.size();
	for(int i=0;i<l;++i){
		int c=sgn(s[i]);
		if(!nxt[p][c]) nxt[p][c]=++cnt;
		p=nxt[p][c];
	    t[p]++;
	}
}

int find(string s){
	int p=0,l=s.size();
	for(int i=0;i<l;++i){
		int c=sgn(s[i]);
        p=nxt[p][c];
		if(p==0)
		    return 0;
	}
	return t[p];
}
```



## 2、KMP

```c++
#include<bits/stdc++.h>
using namespace std;
//#define int long long
#define ll long long
const int maxn=1e6+10;
const int N=2e9+10;

int ne[maxn]; 
char s[maxn],t[maxn];
 
signed main()
{
    cin>>s+1>>t+1;
    int ls=strlen(s+1);
	int lt=strlen(t+1);
	int j=0;
	//求next数组 
	for(int i=2;i<=lt;i++){
		while(j&&t[i]!=t[j+1]){
			j=ne[j];
		}
		if(t[i]==t[j+1]){
			j++;
		}
		ne[i]=j;
	} 
    for(int i=1,j=0;i<=ls;i++){
    	while(j&&s[i]!=t[j+1]) j=ne[j];
    	//当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。
		 
    	if(s[i]==t[j+1]) j++;//匹配成功 
    	
    	if(j==lt){
    		cout<<i-lt+1<<endl; // 输出成功匹配的时候t在s中的位置 
		}
	}
	for(int i=1;i<=lt;i++){
		cout<<ne[i]<<" ";
	}
	
 
	return 0;
}
```





## 3、字符串哈希

全称字符串前缀哈希法，把字符串变成一个p进制数字（哈希值），实现不同的字符串映射到不同的数字。
对形如$ X_1X_2X_3⋯X_{n−1}X_n$ 的字符串,采用字符的ascii 码乘上 P 的次方来计算哈希值。

 映射公式

 $(X_1 \times P^{n-1} + X_2 \times P^{n-2} + \cdots + X_{n-1} \times P^1 + X_n \times P^0) \bmod Q$



```cpp
 #include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ULL;
const int N = 1e5+5,P = 131;//131 13331
ULL h[N],p[N];

// h[i]前i个字符的hash值
// 字符串变成一个p进制数字，体现了字符+顺序，需要确保不同的字符串对应不同的数字
// P = 131 或  13331 Q=2^64，在99%的情况下不会出现冲突
// 使用场景： 两个字符串的子串是否相同
ULL query(int l,int r){
    return h[r] - h[l-1]*p[r-l+1];
}
int main(){
    int n,m;
    cin>>n>>m;
    string x; cin>>x;
    //字符串从1开始编号，h[1]为前一个字符的哈希值
    p[0] = 1;h[0] = 0;
    for(int i=0;i<n;i++){
        p[i+1] = p[i]*P;            
        h[i+1] = h[i]*P +x[i];      //前缀和求整个字符串的哈希值
    }

    while(m--){
        int l1,r1,l2,r2;
        cin>>l1>>r1>>l2>>r2;
        if(query(l1,r1) == query(l2,r2)) printf("Yes\n");
        else printf("No\n");
    }
    return 0;
}
```





## AC自动机



# 三、数据结构

## 1、带权并查集

并查集

```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
#define fast std::ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
/**
 * 参考：并查集《啊哈算法》p208
*/
const int maxn = 1e5+10;
int n,m,sum;
int f[maxn];
void init(){
    int i;
    for(int i=1;i<=n;i++){
        f[i]=i;
    }
    return;
}
int getf(int v){  //f[v]=getf(f[v]);return f[v];
     if(f[v]!=v){
        f[v]=getf(f[v]);
     }
	 return f[v];
    
}
void merge(int v,int u){ // f[getf(v)]=getf(u);
    int t1,t2;
    t1=getf(v);
    t2=getf(u);
    if(t1!=t2){
        f[t1]=t2;//t1父节点是t2
    }
    return;
}
int main(){
    //freopen("1.in","r",stdin); 
    fast
    int i,x,y;
    char p;
    cin>>n>>m;
    init();
    for(i=1;i<=m;i++){
        cin>>p>>x>>y;
        if(p=='M'){
            merge(x,y);
        }else if(p=='Q'){
            if(getf(x)==getf(y)){
                cout<<"Yes"<<endl;
            }else{
                cout<<"No"<<endl;
            }
        }
    }
    return 0 ;
}
```





带权并查集

```c++
int fa[N],value[N];

void init(){
    for(int i=1;i<=n;++i) fa[i]=i;
}

int find(int x){
	if(x!=fa[x]){
		int t=fa[x];
		fa[x]=find(fa[x]);
		value[x]+=value[t];
	}
	return fa[x];
} 

void merge(int a,int b,int s){    //s为a到b权值 
	int x=find(a),y=find(b);
	if(x!=y){
		fa[x]=y; //fa[find(a)]=find(b);
		value[x]=-value[a]+value[b]+s;
	}
}
```



## 2、树状数组

```c++
 #include <bits/stdc++.h>
using namespace std;

int n,m;
int a[50005],c[50005]; //对应原数组和树状数组

int lowbit(int x){
    //表示求数组下标二进制的非0最低位所表示的值
    return x&(-x);
}

void updata(int i,int k){    //在i位置加上k
    while(i <= n){
        c[i] += k;
        i += lowbit(i);
    }
}

int getsum(int i){        //求A[1 - i]的和
    int res = 0;
    while(i > 0){
        res += c[i];
        i -= lowbit(i);
    }
    return res;
}

int main(){
    int t;
    cin>>t;
    for(int tot = 1; tot <= t; tot++){
        cout << "Case " << tot << ":" << endl;
        memset(a, 0, sizeof a);
        memset(c, 0, sizeof c);
        cin>>n;
        for(int i = 1; i <= n; i++){
            cin>>a[i];
            updata(i,a[i]);  
            //输入初值的时候，也相当于更新了值
        }

        string s;
        int x,y;       
        while(cin>>s && s[0] != 'E'){
            cin>>x>>y;
            if(s[0] == 'Q'){    //求和操作
                int sum = getsum(y) - getsum(x-1);   
                //x-y区间和也就等于1-y区间和减去1-(x-1)区间和
                cout << sum << endl;
            }
            else if(s[0] == 'A'){
                updata(x,y);
            }
            else if(s[0] == 'S'){
                updata(x,-y);    
                //减去操作，即为加上相反数
            }
        }

    }
    return 0;
}
 
```





.区间更新、单点查询, 区间查询

```cpp
int main(){
   cin>>n;
    for(int i = 1; i <= n; i++){
         cin>>a[i];
       updata(i,a[i] - a[i-1]);   
           //输入初值的时候，也相当于更新了值
     }
     //[x,y]区间内加上k
    updata(x,k);    //A[x] - A[x-1]增加k
     updata(y+1,-k);        //A[y+1] - A[y]减少k
    
     //查询i位置的值(单点查询)
     int sum = getsum(i);
    
    //求[x,y]区间和(区间查询)
    int sum = getsum(y) - getsum(x-1);
 
     return 0;
 }
```



## 3、线段树

1.单点修改，区间查询（无pushdown)

```cpp
#include<bits/stdc++.h>
using namespace std;
#define fast std::ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);

struct node{
    int left;int right;int num;
}T[150011];
void construct(int l,int r,int k){//建树
    int mid;
    if(l==r){
        T[k].left=l;T[k].right=r;T[k].num=0;
        return;
    }
    mid=(l+r)>>1;
    T[k].left=l;T[k].right=r;T[k].num=0;
    construct(l,mid,2*k);
    construct(mid+1,r,2*k+1);
}
void insert(int n,int d,int k){  //插入  temp为要增加的值
    int mid;  // d指得是C插入的位置
    //k的地方为1 ，即是 从根节点开始往下找
    if(T[k].left==T[k].right&&T[k].left==d){
        T[k].num+=n;
        return;
    }
    mid=(T[k].left+T[k].right)>>1;
    if(d<=mid){//在哪往哪跑
        insert(n,d,2*k);
    }else{
        insert(n,d,2*k+1);
    }
    T[k].num=T[k*2].num+T[k*2+1].num;
}
int ans;
void search(int l,int r,int k){
    int mid;
    if(T[k].left==l&&T[k].right==r){
        ans+=T[k].num;
        return;
    }
    mid=(T[k].left+T[k].right)>>1;
    if(r<=mid){
        search(l,r,2*k);
    }else if(l>mid)   search(l,r,2*k+1);
    else{
         search(l,mid,2*k);
	   	 search(mid+1,r,2*k+1);
    }
}
int N,temp,i,j,k,t,a,b,Case_;
char str[14];
int main(){
    fast
    scanf("%d",&t);
    for(Case_=1;Case_<=t;Case_++){
        scanf("%d",&N);
        construct(1,N,1);
        for(i=1;i<=N;i++){
            scanf("%d",&temp);
            insert(temp,i,1);
        }
        printf("Case %d:\n",Case_);
        while(~scanf("%s",str),strcmp(str,"End")){
            scanf("%d%d",&a,&b);
            if(strcmp(str,"Add")==0){
                insert(b,a,1);
            }else if(strcmp(str,"Sub")==0){
                insert(-b,a,1);
            }else {
                ans=0;search(a,b,1);
                printf("%d\n",ans);
            }
        }
    }
    return ans;
}
```

2. 区间修改，区间查询

```cpp
#include<bits/stdc++.h>
using namespace std;
#define fast std::ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define ll long long int
const int maxn=1e6+10;

ll ans[maxn<<2];//存放结点p的区间和；
ll a[maxn<<2]; //存放数组第i个值；
ll tag[maxn<<2];
ll n,m;
inline ll ls(ll p){ //p的左二子
  return (p<<1);
}
inline ll rs(ll p){//p的右儿子
    return (p<<1|1);
}
inline void push_up(ll p){//自低向上合并
    ans[p]=(ans[ls(p)]+ans[rs(p)]);
}
inline void f(ll p,ll l,ll r,ll k){ // 消除一个lazy标记
    tag[p]+=k;
    ans[p]+=k*(r-l+1);
}
inline void push_down(ll p,ll l, ll r ){//自顶向下消除懒lazy标记 
    ll mid=(r+l)>>1;
    f(ls(p),l,mid,tag[p]);
    f(rs(p),mid+1,r,tag[p]);
    tag[p]=0;
}
void build(ll p,ll l,ll r){
    tag[p]=0;
    if(l==r){
        ans[p]=a[l];
        return;
    }
    ll mid=(l+r)>>1;
    build(ls(p),l,mid);
    build(rs(p),mid+1,r);
    push_up(p);
}
//维护区间[nl。。。nr]加k 
inline void updata(ll nl,ll nr,ll l,ll r,ll p,ll k){
    if(nl<=l&&nr>=r){
        tag[p]+=k;
        ans[p]+=k*(r-l+1);
        return;
    }
    push_down(p,l,r);
    ll mid=(l+r)>>1;
    if(mid>=nl)updata(nl,nr,l,mid,ls(p),k);
    if(mid<nr) updata(nl,nr,mid+1,r,rs(p),k);
    push_up(p);
}
//求q_l...q_r的区间和 
ll query(ll q_l,ll q_r,ll l,ll r,ll p){
    ll res=0;
    if(q_l<=l&&r<=q_r){
        return ans[p];
    }
    push_down(p,l,r);
    ll mid=(l+r)>>1;
    if(mid>=q_l) res+=query(q_l,q_r,l,mid,ls(p));
    if(mid<q_r) res+=query(q_l,q_r,mid+1,r,rs(p));
    return res;
}

int main(){
    int op;
    ll l,r,nl,nr,q_l,q_r,k;
    scanf("%lld %lld",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%lld",&a[i]);
    }
    build(1,1,n);
    for(int i=0;i<m;i++){
        scanf("%d",&op);
        if(op==1){
             scanf("%lld %lld %lld",&l,&r,&k);
             updata(l,r,1,n,1,k);
        }else{ // op==2
           scanf("%lld %lld",&l,&r);
           printf("%lld\n",query(l,r,1,n,1));
        }
    }
    return 0;
}
```

3.乘法加法线段树

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1000001;
ll n,m,mod;
ll a[maxn],tag_add[maxn<<2],tag_mul[maxn<<2],ans[maxn<<2];

inline ll ls(ll p){
	return p<<1;
}
inline ll rs(ll p){
	return p<<1|1;
}
inline void push_up(ll p){
	ans[p]=(ans[ls(p)]+ans[rs(p)])%mod;
}

inline void push_down(ll p,ll l,ll r){
	ll mid=(l+r)>>1;
	//更新值 
	ans[ls(p)]=(ans[ls(p)]*tag_mul[p]+tag_add[p]*(mid-l+1))%mod;
	ans[rs(p)]=(ans[rs(p)]*tag_mul[p]+tag_add[p]*(r-mid-1+1))%mod;
	//更新左右孩子乘法标记 
	tag_mul[ls(p)]=(tag_mul[ls(p)]*tag_mul[p])%mod;
	tag_mul[rs(p)]=(tag_mul[rs(p)]*tag_mul[p])%mod;
	//更新左右孩子加法标记 
	tag_add[ls(p)]=(tag_add[ls(p)]*tag_mul[p]+tag_add[p])%mod; 
	tag_add[rs(p)]=(tag_add[rs(p)]*tag_mul[p]+tag_add[p])%mod; 
	//更新父节点标记 
	tag_add[p]=0;tag_mul[p]=1;
}

inline void build(ll p,ll l,ll r){
	tag_add[p]=0;
	tag_mul[p]=1;
	if(l==r){ans[p]=a[l];return ;}
	ll mid=(l+r)>>1;
	build(ls(p),l,mid);
	build(rs(p),mid+1,r);
	push_up(p);
}

inline void update_add(ll nl,ll nr,ll l,ll r,ll p,ll k){
	if(nl<=l&&r<=nr){
		ans[p]=(ans[p]+k*(r-l+1))%mod;
		tag_add[p]=(tag_add[p]+k)%mod;
		return ;
	}
	push_down(p,l,r);
	ll mid=(l+r)>>1;
	if(mid>=nl)update_add(nl,nr,l,mid,ls(p),k);
	if(mid<nr)update_add(nl,nr,mid+1,r,rs(p),k);
	push_up(p);
}

inline void update_mul(ll nl,ll nr,ll l,ll r,ll p,ll k){
	if(nl<=l&&r<=nr){
		ans[p]=(ans[p]*k)%mod;
		tag_mul[p]=(tag_mul[p]*k)%mod;
		tag_add[p]=(tag_add[p]*k)%mod;
		return ;
	}
	
	push_down(p,l,r);
	ll mid=(l+r)>>1;
	if(mid>=nl)update_mul(nl,nr,l,mid,ls(p),k);
	if(mid<nr)update_mul(nl,nr,mid+1,r,rs(p),k);
	push_up(p);
}

ll query(ll q_l,ll q_r,ll l,ll r,ll p){
	ll res=0;
	if(q_l<=l&&r<=q_r){
		return ans[p];
	}
	push_down(p,l,r);
	ll mid=(l+r)>>1;
	if(mid>=q_l)res=(res+query(q_l,q_r,l,mid,ls(p)))%mod;
	if(mid<q_r)res=(res+query(q_l,q_r,mid+1,r,rs(p)))%mod;
	return res;
}

int main(){
	int op;
	ll l,r,k;
	scanf("%lld %lld %lld",&n,&m,&mod);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
	}
	build(1,1,n);
	for(int i=0;i<m;i++){
		scanf("%d",&op);
		if(op==1){
			scanf("%lld %lld %lld",&l,&r,&k);
			update_mul(l,r,1,n,1,k);
		}else if(op==2){
			scanf("%lld %lld %lld",&l,&r,&k);
			update_add(l,r,1,n,1,k);
		}else if(op==3){
			scanf("%lld %lld",&l,&r);
			printf("%lld\n",query(l,r,1,n,1));
		}
	}
	return 0;
}
```



wjl

```c++
int w[N<<2],tag[N<<2],a[N],n;

void pushdown(int u,int len){
	tag[u<<1]+=tag[u];
	tag[u<<1|1]+=tag[u];
	w[u<<1]+=tag[u]*(len-len/2);
	w[u<<1|1]+=tag[u]*(len/2);
	tag[u]=0;
}

int query(int l,int r,int u=1,int cl=1,int cr=n){
	if(l<=cl && cr<=r) return w[u];
    pushdown(u,cr-cl+1);
	int mid=(cl+cr)>>1,ans=0;
	if(mid>=l) ans+=query(l,r,u<<1,cl,mid);
	if(mid<r) ans+=query(l,r,u<<1|1,mid+1,cr);
	return ans;
}

void add(int l,int r,int k,int u=1,int cl=1,int cr=n){
    if(l<=cl && cr<=r){
		w[u]+=k*(cr-cl+1);
		return;
	}
    pushdown(u,cr-cl+1);
	int mid=(cl+cr)>>1;
	if(mid>=l) add(l,r,k,u<<1,cl,mid);
	if(mid<r) add(l,r,k,u<<1|1,mid+1,cr);
	w[u]=w[u<<1]+w[u<<1|1];
}

void build(int l,int r,int u=1){
	if(l==r){
		w[u]=a[l];
		return;
	}
	int mid=(l+r)>>1;
	build(l,mid,u<<1);
	build(mid+1,r,u<<1|1);
	w[u]=w[u<<1]+w[u<<1|1];
}
```

## 4、二维差分前缀和

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N = 1e3 + 10;
int a[N][N], b[N][N];
void insert(int x1, int y1, int x2, int y2, int c)
{
    b[x1][y1] += c;
    b[x2 + 1][y1] -= c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y2 + 1] += c;
}
int main()
{
    int n, m, q;
    cin >> n >> m >> q;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            cin >> a[i][j];
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            insert(i, j, i, j, a[i][j]);      //构建差分数组
        }
    }
    while (q--)
    {
        int x1, y1, x2, y2, c;
        cin >> x1 >> y1 >> x2 >> y2 >> c;
        insert(x1, y1, x2, y2, c);
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];  //二维前缀和
        }
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            printf("%d ", b[i][j]);
        }
        printf("\n");
    }
    return 0;
}

 
```

## 5.st表

求区间[x,y]的最大值

```cpp
//Sparse Table 稀疏表
#include<bits/stdc++.h>
using  namespace std;

int n,m,x,y,a[100010],lg[100010],f[100010][20];
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
    while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
    return x*f;
}
//注意输入和输出！！用快读和printf 不然狠狠滴TLE呜呜呜
int main(){
    lg[1]=0;
    n=read();m=read();
    for(int i=2;i<=n;i++){
        lg[i]=lg[i>>1]+1;
    }
    for (int i=1;i<=n;i++){
        f[i][0]=read();
    }  
    for(int j=1;j<=lg[n];j++){
        for(int i=1;i<=n-(1<<j)+1;i++){
       	 f[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]);
		}
	}
    //求区间[x,y]的最大值
    for(int i=1;i<=m;i++){
        x=read(),y=read();
        int l=lg[y-x+1];
        printf("%d\n",max(f[x][l],f[y-(1<<l)+1][l]));
	}
    return 0;
}
```







# 九、杂项

## 快读

`#define fast std::ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);`



~~~c++
inline int read()
{
    int x=0,k=1; char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')k=-1;c=getchar();}
    while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*k;
}
~~~





## 1.快速幂和逆元

$$
n^nmod (n+2)。
$$


~~~c++
#include<bits/stdc++.h>
using namespace std;
#define fast std::ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
const int mod=1e9+7;
const int maxn=5e5+100;

long long n,ans;

long long pow(long long a, long long b, long long m) {//快速幂模板 
  a %= m;
  long long res = 1;
  while (b > 0) {
    if (b & 1) res = res * a % m; 
     // 相当于 b%2!=0
    a = a * a % m;
    b >>= 1;	//b/=2; (把二进制表示的b的末位删去)
  }
  return res;
}
int main()
{	 cin>>n;
     ans=pow(n,n,n+2);
 	 //ans=pow(a,n-2,n); 求a%n 的乘法逆元
     cout<<ans;
	return 0;
}
~~~

逆元

b|a  (b能整除a)



```cpp
 #include <iostream>
using namespace std;
typedef long long LL;

LL qmi(int a, int b, int p)
{
    LL res = 1;
    while(b){
        if(b & 1) res = res * a % p;
        a = (LL)a *a % p;
        b >>= 1;
    }
    return res;
}

int main()
{
        int a, p;
    //求 a 模 p 的乘法逆元
        cin >> a >> p;
        if(a % p == 0) puts("impossible");
        else cout << qmi(a, p - 2, p) << endl;
    	//费马小定理
    return 0;
}

 
```



Z

```cpp
#include<bits/stdc++.h>

using namespace std;
using LL = long long ;
//const int N = 1e5 + 10;
const int P = 1e9 + 7;
int norm(int x) {
    if (x < 0) {
        x += P;
    }
    if (x >= P) {
        x -= P;
    }
    return x;
}
template<class T>
T power(T a, LL b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}
struct Z {
    int x;
    Z(int x = 0) : x(::norm(x)) {}
    Z(LL x) : x(::norm(x % P)) {}
    int val() const {
        return x;
    }
    Z operator-() const {
        return Z(::norm(P - x));
    }
    Z inv() const {
        assert(x != 0);
        return power(*this, P - 2);
    }
    Z &operator*=(const Z &rhs) {
        x = LL(x) * rhs.x % P;
        return *this;
    }
    Z &operator+=(const Z &rhs) {
        x = ::norm(x + rhs.x);
        return *this;
    }
    Z &operator-=(const Z &rhs) {
        x = ::norm(x - rhs.x);
        return *this;
    }
    Z &operator/=(const Z &rhs) {
        return *this *= rhs.inv();
    }
    friend Z operator*(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res *= rhs;
        return res;
    }
    friend Z operator+(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res += rhs;
        return res;
    }
    friend Z operator-(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res -= rhs;
        return res;
    }
    friend Z operator/(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res /= rhs;
        return res;
    }
    friend std::istream &operator>>(std::istream &is, Z &a) {
        LL v;
        is >> v;
        a = Z(v);
        return is;
    }
    friend std::ostream &operator<<(std::ostream &os, const Z &a) {
        return os << a.val();
    }
};
void solve()
{
    
    LL n ;
    cin >> n ;
    
    Z ans = power(Z(2) , n - 2); // power(Z(a),b); -> a^b
    
    ans *= n;
    ans *= (n - 1);
    cout << ans << "\n";
	return ;
}
```

## 2.二分

>1. 最朴素的二分查找，查找数num.
>2. 第一个与数num相等的值得位置。`=`
>3. 第一个大于等于num的数 `>=`  ,即：`lower_bound( begin,end,num)`
>4. 第一个大于num的数        `>`,  即：`upper_bound( begin,end,num)`
>5. 第一个小于等于num的数 `<=` ,即：`lower_bound( begin,end,num,greater<type>() )`
>6. 第一个小于num的数        ` <`,即：`upper_bound( begin,end,num,greater<type>() )`
>7. 最后一个与数num相等的数。`=`
>8. 最后一个小于等于num的数。 `<=`
>9. 最后一个小于num的数 `<`

1.最朴素的二分查找，查找数num.

```cpp
#include<bits/stdc++.h>
using namespace std;
 
int x,n,a[105];
bool flag=false;
 
void f(int l,int r){
	int mid=(l+r)/2;
	if(l>r)return ;
	if(a[mid]==x){
		flag=true;
		return ;
	}
	if(a[mid]<x)f(l,mid-1);
	if(a[mid]>x)f(mid+1,r);
	return ;
} 
 
int main(){
	cin>>n>>x;
	for(int i=1;i<=n;i++){
		cin>>a[i]; 
	} 
	sort(a+1,a+n+1,greater<int>());//防止缺德、毒瘤数据 
	f(1,n);
	if(flag)cout<<"YES"<<endl;
	else cout<<"NO"<<endl;
	return 0; 
}
```

2.第一个与数num相等的值的位置。`=`

```cpp
void f(int l,int r){
    int left = l;
	int right = r;
    while (left <= right) { // 这里是 <=
        int mid = (left + right) >>1;
        if (a[mid] >= key) {
            right = mid - 1;
        }else {
            left = mid + 1;
        }
    }
    if (left < n && a[left] == key) {
        return left;
    } 
    return -1;//不一定有相等的
}

```

7.最后一个与数num相等的数。

```cpp
void f(int l,int r){
    int left = l;
	int right = r;
    
    while (left <= right) {  
        int mid = (left + right) >>1;
        if (a[mid] <= key) { // 差别  这里是 <=
            left = mid + 1;
        }
        else {
            right = mid - 1;
        } 
    }
    if (right >= 0 && a[right] == key) {
        return right; 
    }
    return -1;
}

```



8.最后一个小于等于num的数。 `<=`

```cpp
void f(int l,int r){
    int left = l;
	int right = r;
    
    while (left <= right) {
        int mid = (left + right) >>1;
        if (a[mid] > key) { // 这里是 >
            right = mid - 1;
        }
        else {
            left = mid + 1; } 
    }
    return right;
}

```

9.最后一个小于num的数

同上，除了第七排--- > ` if (a[mid] >= key)`





# 四、图论

## 16、树的直径

DEF：树上任意两节点之间最长的简单路径即为树的「直径」

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N =1e5+10;
typedef long long ll;
ll h[N],e[N],ne[N],idx,d[N],w[N];
bool vis[N];
void add(int x,int y,int z){
    e[idx]=y;
    w[idx]=z;
    ne[idx]=h[x];
    h[x]=idx++;
}
void dfs(int x,int father){
    for(int i=h[x];i!=-1;i=ne[i]){
        int j=e[i];
        if(j==father) continue;
        d[j]=d[x]+w[i];
        //更新每个点到起始点的距离（在树中任意两点的距离是唯一的）
        dfs(j,x);//继续搜索下一个节点
    }
}


int main(){
    int n,m,e;
    cin>>n>>m;
    memset(h,-1,sizeof(h));
    char c[2];
    int x,y,z;
    while(m--){//建无向图
        cin>>x>>y>>z>>c;
        add(x,y,z);
        add(y,x,z);
    }
    dfs(1,0);
    ll ans=-1;
    for(int i=1;i<=n;i++){
        if(d[i]>ans){
            ans=d[i];e=i;
        }
    }
    memset(d,0,sizeof(d));
    dfs(e,0);
    for(int i=1;i<=n;i++){
        if(d[i]>ans){
            ans=d[i];
        }
    }
    cout<<ans<<endl;

    return 0;
}
```



## 17、树的重心



```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long int
const int N=1e5+10,M=N*2;
// M-- 以有向图的格式存储无向图，所以每个节点至多对应2n-2条边
 
int h[N]; //邻接表存储树，有n个节点，所以需要n个队列头节点
int e[M]; //存储元素
int ne[M]; //存储列表的next值
int idx; //单链表指针
int n; //题目所给的输入，n个节点
int ans = N; //表示重心的所有的子树中，最大的子树的结点数目
bool st[N]; //记录节点是否被访问过，访问过则标记为true


//a所对应的单链表中插入b , a作为根 
void add(int a,int b){
	e[idx]=b;
	ne[idx]=h[a];
	h[a]=idx++;
}
// 以u为根的子树中点的数量 
int dfs(int u){
	int res=0;//存储 ，删掉某个结点之后，最大连通子图节点数
	st[u]=true;// 标记访问过的u结点
	int sum=1;//存储以u为根的树的节点数，包括u
	//访问u的每个节点
	for(int i=h[u];i!=-1;i=ne[i]){
		int j=e[j];
		if(!st[j]){
			int s=dfs(j); // u 节点的单棵子树节点数
			res=max(res,s);// 记录最大连通子图的节点数
			sum+=s;//以j为根的树的节点数 
		}
	} 
	res=max(res,n-sum);//选择u节点为重心，最大的连通子图的节点数
	ans=min(res,ans); 
	return sum;
	 
}
int main(){
	memset(h,-1,sizeof(h));
	//初始化h数组 -1表示尾节点
	cin>>n;
	// 树中是不存在环的，对于有n个节点的树，必定是n-1条边
	for(int i=0;i<n;i++){
		int a,b;
		cin>>a>>b;
		add(a,b),add(b,a);
	}
	dfs(1);
	cout<<ans<<endl;
	
	return 0;
} 
```

18.对顶堆

```cpp
 #include<bits/stdc++.h>
using namespace std;
#define int long long
#define fast std::ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
const int N=1e5+10;
int a[N];
priority_queue<int,vector<int>,less<int>> q1;//大根堆
priority_queue<int,vector<int>,greater<int>> q2;//小根堆
void solve(){
    int n;cin>>n;
    for(int i=0;i<n;i++){cin>>a[i];}
    q2.push(a[0]);
    cout<<a[0]<<endl;
    for(int i=1;i<n;i++){
        if(a[i]>q2.top()) q2.push(a[i]);
        else q1.push(a[i]);
        if((i+1)%2!=0){ 
            int k=(i+2)/2; //动态维护第k大的值
            while(q2.size()!=k ){
                if(q2.size()>k){
                    q1.push(q2.top());q2.pop();
                }
                if(q2.size()<k){
                    q2.push(q1.top());q1.pop();
                }
            }
            cout<<q2.top()<<"\n";
        }  
    }
}
```

## 18.拓扑排序



```cpp
#include<bits/stdc++.h>
using namespace std;
#define fastio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> PII; //堆里存储距离和节点编号
const int N = 1e6+10;
const int M = 1e5+10;
int h[N],w[N],e[N],ne[N],idx;// 邻接表存图 
// head
int q[N],d[N]; //d[N] 保存各个点的入度
bool st[N];
int hh=0,tt=-1,n,m;//节点数量和边数
void add(int u,int v){
    e[idx]=v;ne[idx]=h[u];h[u]=idx++;
} 
bool topsort(){ 
    for(int i=1;i<=n;i++){
        if(!d[i]){ // 如果入度为0，就入队
            q[++tt]=i;
        }
    }
    while(tt>=hh){ //循环处理队列中的点
        int a =q[hh++];
        for(int i=h[a];i!=-1;i=ne[i]){//循环删除 a 发出的边
            int b=e[i];
            d[b]--;
            if(d[b]==0){ //如果b的入度减为 0,则 b 可以输出，入队列
              q[++tt]=b;
            }
        }
    }
    if(tt==n-1){//如果队列中的点的个数与图中点的个数相同，则可以进行拓扑排序
        for(int i=0;i<n;i++){//队列中保存了所有入度为0的点，依次输出
            cout<<q[i]<<" ";
        }
    } else{cout<<-1;} 
}
int main(){
	fastio
    cin>>n>>m;
    memset(h,-1,sizeof(h));
    for(int i=0;i<m;i++){
        int a,b;
        cin>>a>>b;
         d[b]++;//顶点b的入度+1
        add(a,b);
    }
    topsort();
	return 0;
}
```





## 1、二分图判断->染色()

```cpp
 #include<bits/stdc++.h>
#define maxn 1000010
using namespace std;
int t,n,m;
int u[maxn],v[maxn];
vector<int> e[maxn];
int col[maxn];
bool vis[maxn];
int cnt;

inline void check(int u,int tp){
	vis[u]=1;
	col[u]=tp;
	for(int i=0;i<e[u].size();++i){ //  ++i比 i++ 快
		int v=e[u][i];
		if(vis[v]==0){
			check(v,tp^1);
		}
	}
}

signed main(){
	ios::sync_with_stdio(0);
	cin>>t;
	while(t--){
		cnt++;
		cout<<"Scenario #"<<cnt<<":"<<endl;
		cin>>n>>m;
		for(int i=1;i<=m;++i){
			cin>>u[i]>>v[i];
			e[u[i]].push_back(v[i]);
			e[v[i]].push_back(u[i]);
		}
		bool flag=0;
		for(int i=1;i<=n;++i){
			if(vis[i]==0){ check(i,0); }
		}
		for(int i=1;i<=m;++i){
			if(col[u[i]]==col[v[i]]){
				flag=1; break;
			}
		}
		if(flag==1){ cout<<"YES!"<<endl<<endl; }
		else{ cout<<"No!"<<endl<<endl; }
        for(int i=1;i<=n;++i){
			e[i].clear();
			vis[i]=0; col[i]=0;
		}
	}
	return 0;
}
```

wjl

```c++
int c[N];

bool dfs(int x,int u){
	c[x]=u;
	for(auto y:v){                    //邻接表实现
		if(c[y]==u) return false;
        if(!c[y] && !dfs(y,-u)) return false;
	}
	return true;
}

bool bi_graph(){
	for(int i=1;i<=n;++i){
		if(c[i]==0 && !dfs(i,1))
		    return false;
	}
	return true;
}
```



## 2、二分图最大匹配

```c++
int match[N],t[N];

bool dfs(int x,int y){
	for(int j=head[x];j;j=e[j].next){
		int i=e[j].to;
		if(t[i]!=y){
			t[i]=y;
			if(match[i]==0||dfs(match[i],y)){
				match[i]=x;
				return true;
			}
		}
	}
	return false;
}
```



```cpp
 #include<bits/stdc++.h>
using namespace std;
const int N = 305, M = 50005;
struct E {
	int v, next;
} e[M];
int t, n, m, p, k, v, head[N], len, mat[N];
bool vis[N];  
void add(int u, int v) {
	e[len].v = v;
	e[len].next = head[u];
	head[u] = len++;
} 
bool find(int u) {
	for (int j = head[u]; j; j = e[j].next) {
		int v = e[j].v;
		if (!vis[v]) {
			vis[v] = true;
			if (mat[v] == 0 || find(mat[v])) {
				//如果v这个同学没匹配 || 踹掉v匹配的课程
				mat[v] = u;
				return true; //匹配成功 
			}
		}
	}
	return false;
} 
int main() {
	scanf("%d", &t);
	while (t--) {
		len = 1;
		memset(head, 0, sizeof(head)); //初始化边 
		memset(mat, 0, sizeof(mat));
		scanf("%d%d", &p, &n); //p个课程 n个学生
		for (int u = 1; u <= p; u++) {
			scanf("%d", &k);
			for (int j = 1; j <= k; j++) {
				scanf("%d", &v);
				//代表这个课程指向这个学生
				add(u, v); 
			}
		} 
		int ans = 0;
		//找出课程能够匹配的最大量
		for (int i = 1; i <= p; i++) {
			memset(vis, false, sizeof(vis));  
			if (find(i)) ans++; //匹配成功一门课程 
		} 
		if (ans == p) printf("YES\n");
		else printf("NO\n");
	}
	return 0;
}

```



## 3、最短路-Dijkstra

堆优化

```c++
int dis[N],vis[N];
priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;

void dijkstra(int s){ // 起点为s
    memset(dis,0x3f,sizeof(dis));
    dis[s]=0;    
	pq.push({0,s});
    while(!pq.empty()){
		int x=pq.top().first,y=pq.top().second;
		pq.pop();
		if(vis[y]) continue;
		vis[y]=1;
    	for(int i=head[y];i;i=e[i].next){
    		if(dis[e[i].to]>x+e[i].w){
			    dis[e[i].to]=x+e[i].w;
    		    pq.push({dis[e[i].to],e[i].to});
    		}
		}
	}
}
```

## bellman-ford  O(nm)

（存在负权变

```cpp
#include<iostream>
#include<cstring>

using namespace std;

const int N = 510, M = 10010;

struct Edge {
    int a;
    int b;
    int w;
} e[M];//把每个边保存下来即可
int dist[N];
int back[N];//备份数组防止串联
int n, m, k;//k代表最短路径最多包涵k条边

int bellman_ford() {
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    for (int i = 0; i < k; i++) {//k次循环
        memcpy(back, dist, sizeof dist);
        for (int j = 0; j < m; j++) {//遍历所有边
            int a = e[j].a, b = e[j].b, w = e[j].w;
            dist[b] = min(dist[b], back[a] + w);
            //使用backup:避免给a更新后立马更新b, 这样b一次性最短路径就多了两条边出来
        }
    }
    if (dist[n] > 0x3f3f3f3f / 2) return -0x3f3f3f3f;
    else return dist[n];

}

int main() {
    scanf("%d%d%d", &n, &m, &k);
    for (int i = 0; i < m; i++) {
        int a, b, w;
        scanf("%d%d%d", &a, &b, &w);
        e[i] = {a, b, w};
    }
    int res = bellman_ford();
    if (res == -0x3f3f3f3f) puts("impossible");
    else cout << res;

    return 0;
}
```

**为什么是dist[n]>0x3f3f3f3f/2， 而不是dist[n]>0x3f3f3f3f**

- 5号节点距离起点的距离是无穷大，利用5号节点更新n号节点距离起点的距离，将得到109−2109−2, 虽然小于109109, 但并不存在最短路，(在边数限制在k条的条件下)。




## spfa （优）

（存在负权边)

一般O(m)，最坏O（nm）

```cpp
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;
const int N=1e5+10;
#define fi first
#define se second
typedef pair<int,int> PII;//到源点的距离，下标号
int h[N],e[N],w[N],ne[N],idx=0;
int dist[N];//各点到源点的距离
bool st[N];
int n,m;
void add(int a,int b,int c){
    e[idx]=b;w[idx]=c;ne[idx]=h[a];h[a]=idx++;
}
int spfa(){
    queue<PII> q;
    memset(dist,0x3f,sizeof dist);
    dist[1]=0;
    q.push({0,1});
    st[1]=true;
    while(q.size()){
        PII p=q.front();
        q.pop();int t=p.se;
        st[t]=false;//从队列中取出来之后该节点st被标记为false
        //代表之后该节点如果发生更新可再次入队
        for(int i=h[t];i!=-1;i=ne[i]){
            int j=e[i];
            if(dist[j]>dist[t]+w[i]){
                dist[j]=dist[t]+w[i];
                if(!st[j]){
                    //当前已经加入队列的结点，无需再次加入队列/
                    //即便发生了更新也只用更新数值即可，重复添加降低效率
                    st[j]=true; q.push({dist[j],j});
                } 
            }
        }
    }
    return dist[n];
}
int main(){
    scanf("%d%d",&n,&m);
    memset(h,-1,sizeof h);
    while(m--){
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c);
    }
    int res=spfa();
    if(res==0x3f3f3f3f) puts("impossible");
    else printf("%d\n",res);
    return 0;
}
```



spfa 判断负环

```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>
using namespace std;
const int N = 2010, M = 10010;
int n, m;
int h[N], w[M], e[M], ne[M], idx;
int dist[N], cnt[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

bool spfa()
{
    queue<int> q;

    for (int i = 1; i <= n; i ++ )
    {
        st[i] = true;
        q.push(i);
    }

    while (q.size())
    {
        int t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;

                if (cnt[j] >= n) return true;
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    return false;
}

int main()
{
    scanf("%d%d", &n, &m);

    memset(h, -1, sizeof h);

    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    if (spfa()) puts("Yes");
    else puts("No");

    return 0;
}
 
```



## 4、欧拉路

```c++
 #include <bits/stdc++.h>
using namespace std;
const int MAX=100010;
int n,m,u,v,del[MAX];
int du[MAX][2];//记录入度和出度 
stack <int> st;
vector <int> G[MAX];
void dfs(int now)
{
	for(int i=del[now];i<G[now].size();i=del[now])
	{ 
		del[now]=i+1;//把之前访问过的边标记 
		dfs(G[now][i]);
	}
	st.push(now);
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
        scanf("%d%d",&u,&v);
        G[u].push_back(v),du[u][1]++,du[v][0]++; 
    }  
    for(int i=1;i<=n;i++) sort(G[i].begin(),G[i].end());
    int S=1,cnt[2]={0,0}; //记录
    bool flag=1; //flag=1表示,所有的节点的入度都等于出度,
    for(int i=1;i<=n;i++)
	{
        if(du[i][1]!=du[i][0])
        {
            flag=0;
            if(du[i][1]-du[i][0]==1) cnt[1]++,S=i;/*出度比入度多1*/
            else if(du[i][0]-du[i][1]==1) cnt[0]++;/*入度比出度多1*/
            else return puts("No"),0;
        }
    }
    if((!flag)&&!(cnt[0]==cnt[1]&&cnt[0]==1)) return !puts("No"),0;
	//不满足欧拉回路的判定条件，也不满足欧拉路径的判定条件，直接输出"No" 
    dfs(S);
    while(!st.empty()) printf("%d ",st.top()),st.pop();
    return 0; 
}
```



## 5、负环

```c++
int dis[N],tmp[N],vis[N];
queue<int>q;

bool spfa(int s){
    memset(dis,0x3f,sizeof dis);
    dis[s]=0;
    vis[s]=1;
    q.push(s);
    while(!q.empty()){
    	int u=q.front();
		q.pop();
    	vis[u]=0;
    	for(int i=head[u];i;i=e[i].next){
    		int v=e[i].to,w=e[i].w;
    		if(dis[v]>dis[u]+w){
    		    dis[v]=dis[u]+w;
    		    tmp[v]=tmp[u]+1;
    		    if(tmp[v]>=n) return 1;
				if(!vis[v]) vis[v]=1,q.push(v);
			}
		}
	}
    return 0;
}
```



## 6、差分约束

```c++
//在spfa基础上
for(int i=1;i<=n;++i) add(0,i,0);           //建立超级源点

add(u,v,w);                                 //所有x最大解

add(u,v,-w);                                //所有x最小解

for(int i=1;i<=n;++i) cout<<dis[i]<<" ";    //最短路为一组可行解
```



```cpp
 #include<bits/stdc++.h>
using namespace std;
const int maxn=5005;
const int maxm=6e3+10;
int n,m;
queue<int> Q;
int dis[maxn],vis[maxn],cnt[maxn];
struct Edge{
	int to,w,next;
}edge[2*maxn];        
int head[maxn],tot;
inline void Init(){     
	for(int i=0;i<maxm;i++) edge[i].next=0;
	for(int i=0;i<maxn;i++) head[i]=0;
	tot=0;
}
inline void addedge(int u,int v,int w){
	edge[++tot].to=v;
	edge[tot].w=w;
	edge[tot].next=head[u];
	head[u]=tot;
}
bool spfa(int s){
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	memset(cnt,0,sizeof(cnt));
	dis[s]=0;
    vis[s]=true;
	Q.push(s);
	while(!Q.empty()){
		int x=Q.front();
		//cout<<x<<endl;
		Q.pop();
		vis[x]=false;
		for(int i=head[x];i;i=edge[i].next){
			int y=edge[i].to,z=edge[i].w;
			if(dis[y]>dis[x]+z){
				dis[y]=dis[x]+z;  //更新最短路
				if(!vis[y]){
					cnt[y]++; vis[y]=true;  
					if(cnt[y]==n+1) return true;   
					Q.push(y);
				}
			}
		}
	}
	return false;
}
int main(){
	int T=1;
	//scanf("%d",&T);
	while(T--){
		Init();
		scanf("%d%d",&n,&m);
		for(int i=1;i<=n;i++){
			addedge(0,i,0);
		}
		for(int i=1;i<=m;i++){
			int u,v,w;
			scanf("%d%d%d",&u,&v,&w);
			addedge(v,u,w);
			//if(w>=0) addedge(v,u,w);
		}
		//puts(spfa()?"YES":"NO");
		if(spfa(0)) cout<<"NO"<<endl;
		else{
			for(int i=1;i<=n;i++){
				cout<<dis[i]<<" "; 
			}
		}
	}
	return 0;
}
```





## 7、缩点

```c++
int dfn[N],low[N],tot,tmp,vis[N],id[N];
stack<int>s;

for(int i=1;i<=n;++i){
		if(!dfn[i]) tarjan(i);
	}

void tarjan(int u){
	dfn[u]=low[u]=++tot;
	s.push(u);
	vis[u]=1;
	for(int i=head[u];i;i=e[i].next){
		int v=e[i].to;
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(vis[v]) low[u]=min(low[u],dfn[v]);
	}
	if(low[u]==dfn[u]){
		++tmp;
		while(1){
			int x=s.top();s.pop();
			id[x]=tmp;
			vis[x]=0;
			if(x==u) break;
		}
	}
}
```



```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn=10000+15;
int n,m,sum,tim,top,s;
int p[maxn],head[maxn],sd[maxn],dfn[maxn],low[maxn];

int stac[maxn],vis[maxn]; 
int h[maxn],in[maxn],dist[maxn];
struct EDGE
{
	int to;int next;int from;
}edge[maxn*10],ed[maxn*10];
void add(int x,int y)
{
	edge[++sum].next=head[x];
	edge[sum].from=x;
	edge[sum].to=y;
	head[x]=sum;
}
void tarjan(int x)
{
	low[x]=dfn[x]=++tim;
	stac[++top]=x;vis[x]=1;
	for (int i=head[x];i;i=edge[i].next)
	{
		int v=edge[i].to;
		if (!dfn[v]) {
		tarjan(v);low[x]=min(low[x],low[v]);
	}
	    else if (vis[v])
	    {
	    	low[x]=min(low[x],low[v]);
		}
	}
	if (dfn[x]==low[x])
	{
		int y;
		while (y=stac[top--])
		{
			sd[y]=x;vis[y]=0;
			if (x==y) break;
			p[x]+=p[y];
		}
	}
}
int topo()
{
	queue <int> q;
	int tot=0;
	for (int i=1;i<=n;i++)
	if (sd[i]==i&&!in[i])
	{
		q.push(i);dist[i]=p[i];
	 } 
	while (!q.empty())
	{
		int k=q.front();q.pop();
		for (int i=h[k];i;i=ed[i].next)
		{
			int v=ed[i].to;
			dist[v]=max(dist[v],dist[k]+p[v]);
			in[v]--;
			if (in[v]==0) q.push(v);
		}
	}
    int ans=0;
    for (int i=1;i<=n;i++)
    ans=max(ans,dist[i]);
    return ans;
}
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++) scanf("%d",&p[i]);
    
	for (int i=1;i<=m;i++)
	{
		int u,v;scanf("%d%d",&u,&v);add(u,v);
	}
	for (int i=1;i<=n;i++)
	if (!dfn[i]) tarjan(i);
	for (int i=1;i<=m;i++)
	{
		int x=sd[edge[i].from],y=sd[edge[i].to];
		if (x!=y)
		{
			ed[++s].next=h[x];
			ed[s].to=y;ed[s].from=x;
			h[x]=s;in[y]++;
		}
	}
	printf("%d",topo());
	return 0;
}
```



## 8、2—SAT

```c++
//tarjan同上
                               
add(a+(b&1)*n,c+(d^1)*n);
    	
add(c+(d&1)*n,a+(b^1)*n);        //a为b或b为c

for(int i=1;i<=n;++i){
    if(r[i]==r[i+n]){
        cout<<"IMPOSSIBLE";
		return 0;
    }
}
cout<<"POSSIBLE"<<endl;
for(int i=1;i<=n;++i) cout<<(r[i]<r[i+n])<<" ";

```



## 9、割点

```c++
int dfn[N],low[N],tot

void tarjan(int u,int root){
	dfn[u]=low[u]=++tot;
	int flag=0;
	for(int i=head[u];i;i=e[i].next){
		int v=e[i].to;
		if(!dfn[v]){
			tarjan(v,root);
			low[u]=min(low[u],low[v]);
			if(low[v]>=dfn[u]){
				flag++;
			    if(u!=root || flag>1) cut[u]=1;
			}
		}
		else low[u]=min(low[u],dfn[v]);
	}
}
```



## 10、边双连通

```c++
int dfn[N],low[N],tot,tmp;
vector<int>res[N];
stack<int>st;

void tarjan(int u,int id){
	dfn[u]=low[u]=++tot;
	st.push(u);
	for(int i=head[u];i;i=e[i].next){
		int v=e[i].to;
		if(!dfn[v]){
			tarjan(v,i);
			low[u]=min(low[u],low[v]);
		}
		else if(i!=(id^1)) low[u]=min(low[u],dfn[v]);       //cnt=1;
	}
	if(low[u]==dfn[u]){
		int x=st.top();st.pop();
		res[tmp].push_back(x);
		while(x!=u){
			x=st.top();st.pop();
			res[tmp].push_back(x);
		}
		tmp++;
	}
}
```



## 11、最小生成树-Kruskal

my

```cpp
#include<bits/stdc++.h>
using namespace std;
#define M 5010
const int N = 2e5+10;
struct EDGE{
	int u,v,w;
}e[N];
int f[M];
int n,m;
bool cmp(EDGE e1, EDGE e2){
	return e1.w<e2.w;
}
void init  (){
	for(int i=0;i<=n;i++){f[i]=i;}
	return;
}
int getf(int x){
	if(x==f[x]) return x;
	else return f[x]=getf(f[x]);
}
int main(){
	cin>>n>>m;
	init();
	for(int i=0;i<m;i++){
		cin>>e[i].u>>e[i].v>>e[i].w; 
	}
	sort(e,e+m,cmp);
	int ans=0;
	for(int i=0;i<m;i++){
		if(getf(e[i].u)!=getf(e[i].v)){
			f[getf(e[i].u)]=getf(e[i].v);
			ans+=e[i].w;
		}
	}
	int cnt=0;
	for(int i=1;i<=n;i++){
		if(f[i]==i){cnt++;}
	}
	if(cnt>=2){cout<<"orz"<<endl;}
    else{cout<<ans<<endl;}
}
```



wjl

```c++
int n,ans=1,res,fa[N];
struct node{
	int x,y,z;
	bool operator<(const node&a)const{
		return z>a.z;
	}
};
priority_queue<node>pq;

int find(int x){
	return x==fa[x]?x:fa[x]=find(fa[x]);
}

void kruskal(){
	for(int i=1;i<=n;++i) fa[i]=i;
	while(!pq.empty()){
		if(ans==n) break;
		int u=pq.top().x,v=pq.top().y,w=pq.top().z;
		pq.pop();
		x=find(u),y=find(v);
		if(x!=y){
			fa[x]=y;
			ans++;              //ans==n则图连通
			res+=w;             //res为所有边权和
		}
	}
}
```



## 15、LCA-倍增

```cpp
//倍增
#include<bits/stdc++.h>
using namespace std;
const int inf = 0x3f3f3f3f;
const int max4 = 10000 + 10;
typedef struct Edge{
	int to;\int val;
	Edge(int to = 0 , int val = 0):to(to),val(val){}
}Edge;

vector<Edge>road[4 * max4];		
//road[x]保存从x出发的所有道路，road[x][i].to表示这条路的另一个点
int dis[4 * max4];			//dis[x]记录结点x离根结点的距离
int father[4 * max4][15];		//father[x][j]记录从x点向上2^j次层的祖先结点
int depth[4 * max4];			//depth[x]记录点x的深度
int lg[4 * max4];			//log2n 向下取整

void init()
{
	memset(dis, 0, sizeof(dis));
	memset(father, 0, sizeof(father));
	memset(depth, 0, sizeof(depth));
	for (int i = 0; i < 4 * max4;i++)
		road[i].clear();
}

void dfs(int now,int fa)
{
	depth[now] = depth[fa] + 1;
	father[now][0] = fa;

	//将now点的祖先结点全部记录下来
	for (int j = 1; j <= lg[depth[now]] + 1; j++)
		father[now][j] = father[father[now][j - 1]][j - 1];

	//搜索当前结点的子结点
	for (int i = 0; i < road[now].size();i++)
	{
		if(road[now][i].to != fa)			               
            //如果某一条路是当前结点和父结点的，那么没有必要向上搜索
		{
			dis[road[now][i].to] = dis[now] + road[now][i].val;   
            //子结点到根结点的距离等于父结点到根结点的距离加上这条路的距离
			dfs(road[now][i].to, now);
		}
	}
}

//返回结点u,v的最小公共祖先
int lca(int u,int v)
{
	if (depth[u] < depth[v])
		swap(u, v);

	while (depth[u] != depth[v])
		u = father[u][lg[depth[u] - depth[v]]];

	if (u == v)
		return u;

	for (int i = lg[depth[u]];i >= 0;i--)
	{
		//当两者的某祖先结点不一致的时候，说明还需要继续向上查找
		//当u,v位lca的最近子结点的时候，对于任意的father[u][i]都满足
		//father[u][i] == father[v][i] ，所以最后u,v为lca的最近子结点
		if(father[u][i] != father[v][i])
		{
			u = father[u][i];
			v = father[v][i];
		}
	}
	return father[u][0];
}

int main()
{
	//预处理，lg[x]表示log2n向下取整
	lg[0] = -1;
	for (int i = 1; i < 4 * max4;i++)
		lg[i] = lg[i >> 1] + 1;

	int t;
	scanf("%d",&t);
	while(t--)
	{
		init();
		int n, m;
		scanf("%d%d", &n, &m);
		for (int i = 1; i < n; i++)
		{
			int s, e, v;
			scanf("%d%d%d", &s, &e, &v);
			road[s].push_back({ e,v });
			road[e].push_back({ s,v });
		}
		dfs(1, 0);					
        //树中任意一个结点均可以作为根结点，但是不确定结点的个数，而且编号为1的结点所以的树均有，所以将1作为根结点
		while(m--)
		{
			int s, e;
			scanf("%d%d", &s, &e);
			int k = lca(s, e);
			printf("%d\n", dis[s] + dis[e] - 2 * dis[k]);
		}
	}
	return 0;
}
```





wjl

```c++
int fa[N][(lgN)],dep[N],lg[N];

void init(){
    for(int i=2;i<=n;++i)
	    lg[i]=lg[i>>1]+1;
}

void dfs(int now,int fath){
	fa[now][0]=fath;
	dep[now]=dep[fath]+1;
	for(int i=1;i<=lg[dep[now]];++i)
		fa[now][i]=fa[fa[now][i-1]][i-1];
	for(int i=head[now];i;i=e[i].next)
		if(fath!=e[i].to)
		    dfs(e[i].to,now);
}

int LCA(int x,int y){
	if(dep[x]>dep[y]) swap(x,y);
	while(dep[x]<dep[y])
	    y=fa[y][lg[dep[y]-dep[x]]];
	if(x==y) return x;
	for(int i=lg[dep[x]];i>=0;i--)
	    if(fa[x][i]!=fa[y][i]){
	    	x=fa[x][i];
	    	y=fa[y][i];
		}
	return fa[x][0];
}

```

 

# 十一、TIPS

#### 对拍

①std代码（暴力方法，会TLE，但是能保证正确） ②my代码（准备提交的代码，不清楚正确性） ③data代码（生成数据） ④以下代码

```cpp
#include<bits/stdc++.h>
#include<windows.h>
using namespace std;
signed main(){
	while(1){
		system("data.exe > data.txt");
		system("a.exe < data.txt > a.txt");
		system("b.exe < data.txt > b.txt");
		if(system("fc a.txt b.txt")) break;
	}
}
```

注意：在运行以上文件前，**需要将std my data 三个文件都编译并生成过.exe文件后才可以开始对拍**，如果对拍发现了问题，输入的数据会保存在1.in中，可以去查询自己错在哪里了。



#### 2.1求最小公倍数

~~~c++
int lcm(int x,int y){
    int g;
    g=gcd(x,y);
    return (x*y/g);
}
int gcd(int a int b){
	int r;
	while(b>0){
		r=a%b;a=b;b=r;
	}
	return a;
}       
~~~

#### 4.c++控制输出小数点

~~~c++
#include<iomanip>
...
	cout<<fixed<<setprecision()<<a;
~~~

#### 8.字符串与数字的转换

> 使用系统提供的库函数
>
> ###### 1.字符串传数字
>
>  (1)、使用**stoi()**
>
> ~~~c++
> string s("12345");
> long long a = stoi(s);
> cout << a << endl;
> ~~~
>
>  （2）、使用**atoi()**
>
> ~~~c++
> char str3[10] = "3245345";
> //数字简单，所以转数字一个参数 
> long long a = atoi(str3);  
> cout << a << endl;
> ~~~
>
>  (3)、使用 **sscanf() 映射**
>
> ~~~c++
> long long c = 0;
> char str5[10] = "661234544";
> sscanf(str5, "%d", &c); //从左至右，字符串转数字 
> cout << c << endl;
> ~~~
>
>  (4)、自己写一个简单的
>
> ~~~c++
> //字符串转为整数,通过减'0'字符,底层用ASCII码相减 
> void myAtoi(char str[],long long& m){  
> 	int i(0);
> 	int temp = 0;
> 	while(str[i] != '\0'){
> 		temp = temp*10 + (str[i] -'0');
> 		++i;
> 	}
> 	m = temp; //转换后赋值给m
> } 
> ~~~
>
> **2.数字转字符串**
>
>  (1)、使用c++里的to_string()
>
> ~~~c++
> long long m = 1234566700;
> string str = to_string(m);   //系统提供数字转字符 
> cout << str << endl;
> ~~~
>
>  (2)、使用itoa()
>
> ~~~c++
> int n = 100;
> char str2[10];
> //字符串比较麻烦，所以转字符串三个参数，我是这么记得(手动滑稽） 
> itoa(n,str2,10); //第一个参数为整数，第二个为字符串(char*)，第三个为进制 
> cout << str2 << endl;
> ~~~
>
> (3)、使用sprintf() 映射
>
> ~~~c++
> long long b = 1234560;
> char str4[10] = {0};
> sprintf(str4, "%d", b); //从右至左，把数转换为字符串 
> cout << str4 << endl;
> ~~~
>
>  (4)、自己写一个简单的
>
> ~~~c++
> //整数转为字符串：通过加 '0'字符 
> void myItoa(long long n, char str[]){
> 	char temp[MAX]{0};
> 	int i(0);
> 	int j = 0;
> 	while(n){
> 		temp[i++] = n%10 + '0';
> 		n /= 10; 
> 	}
> 	//此时为逆序，需要调整为正序 
> 	//cout <<  temp << endl;
> 	while(i>0)
> 		str[j++] = temp[--i];
> 	//cout << str << endl;
> } 
> ~~~



#### 9.读入带空格的字符串

~~~c++
string s;
getline(cin,s);
~~~



#### 10.**输入总数未知数据**

~~~c++
while((scanf("%d",&n)!)=EOF) 
    //EOF就是-1，当scanf返回值为-1时停止输入
while((cin>>n)!=0)
     //当cin返回值为0时停止输入
while(~(scanf("%d",&n))) 
~~~



大小写转换

~~~c++
if(ch[j]>='A'&&ch[j]<='Z'){
    ch[j]=ch[j]+('a'-'A');
   }
~~~

#### 3.4 min_element()

`min_element()`和`max_element`

作用：返回容器中最小值和最大值。
max_element(first,end,cmp);其中cmp为可选择参数!
max函数|C++返回数组中的最大值——max_element函数

```cpp
#include<bits/stdc++.h>
using namespace std; 
struct node {
   int x, y;
};
bool cmp1(node a, node b) {
    return a.x > b.x;
}
int main() {
    vector<int> v(3);
    int arr[4];
    vector<node> v1(3);
    cout << *max_element(v.begin(), v.end());
    cout << *min_element(arr, arr + 4);
    cout << (*max_element(v1.begin(), v1.end(), cmp1)).y;
    return 0;
}

```

#### 3.10 next_permutation()

>**next_permutation()** 是 C++ STL 中的一个函数，**用于求一个序列的下一个全排列**。该函数会改变原序列，并返回一个布尔值，表示是否存在下一个全排列。如果存在，则返回 true，并将原序列更新为下一个全排列；如果不存在，则返回 false，并将原序列更新为最初的序列。
>
>

```cpp
#include <iostream>  
#include <algorithm>  
using namespace std;  
int main()  
{  
    int num[3]={1,2,3};  
    do  
    {  
        cout<<num[0]<<" "<<num[1]<<" "<<num[2]<<endl;  
    }while(next_permutation(num,num+3));  
    return 0;  
}  

```

#### 3.11 memcpy(a1,a2);

`memcpy`函数是C/C++语言中的一个用于内存复制的函数，声明在 string.h 中（C++是 cstring）。其原型是：

```cpp
void *memcpy(void *destin, void *source, unsigned n);
```

作用是：以source指向的地址为起点，将连续的n个字节数据，复制到以destin指向的地址为起点的内存中。
函数有三个参数，第一个是目标地址，第二个是源地址，第三个是数据长度。

使用memcpy函数时，需要注意：

- 数据长度（第三个参数）的单位是字节（1byte = 8bit）。
- 注意该函数有一个返回值，类型是void*，是一个指向destin的指针。



#### 斐波那契



#### 求逆序对

1.归并排序的应用

```cpp
int merge_sort(int a[], int l ,int r){
    //序列只有一个数
    if (l == r) return 0;
    //递归左边和右边
    int mid = l + r >> 1;
    int res = merge_sort(a, l , mid) + merge_sort(a, mid + 1, r);
    //归并的过程
    int i = l , j = mid + 1, k = 0;
    while (i <= mid && j <= r){
        if (a[i] <= a[j]) t[k++] = a[i++];
        else{
            t[k++] = a[j++];
            res += mid - i + 1;
        }
    }
    while (i <= mid) t[k++] = a[i++];
    while (j <= r) t[k++] = a[j++];
    
    //还原数组
    for (int i = 0 , j = l ; j <= r ; i ++ , j ++) a[j] = t[i];
    
    return res;
}

```



2.树状数组

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
#define fast std::ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);

const int ma=2e5+100;
int n,m,k;
int a[maxn],c[maxn];
int lowbit(int x){
    return x&(-x);
}

void updata(int i,int k){    //在i位置加上k
    while(i <= n){
        c[i] += k;
        i += lowbit(i);
    }
}

int getsum(int i){        //求A[1 - i]的和
    int res = 0;
    while(i > 0){
        res += c[i];
        i -= lowbit(i);
    }
    return res;
}

void solve(){
    cin>>n;
    int cnt=0;
    memset(a,0,sizeof(a));
     for(int i=1;i<=n;i++){
        cin>>a[i];
        updata(a[i],1);
        cnt+=getsum(n)-getsum(a[i]); 
         //getsum(n) 目前出现的 数 的个数
         //getsum(a[i]) a[i]这个数前面的数 出现的总数   
     }
      
     cout<<cnt<<endl;
     
}
 
signed main(){
    fast
	int t = 1 ;
    //cin >> t ;
	while( t -- ){
		solve();
	} 
    return 0;
}
```

#### 高精度



高精度加法 —— 模板题 AcWing 791. 高精度加法

```c++
// C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);

    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }
    
    if (t) C.push_back(t);
    return C;

}
```



高精度减法 —— 模板题 AcWing 792. 高精度减法

```c++
// C = A - B, 满足A >= B, A >= 0, B >= 0
vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i ++ )
    {
        t = A[i] - t;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;

}
```

高精度乘低精度 —— 模板题 AcWing 793. 高精度乘法

```c++
// C = A * b, A >= 0, b >= 0
vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;

    int t = 0;
    for (int i = 0; i < A.size() || t; i ++ )
    {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }
    
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    
    return C;

}
```

高精度除以低精度 —— 模板题 AcWing 794. 高精度除法

```c++
// A / b = C ... r, A >= 0, b > 0
vector<int> div(vector<int> &A, int b, int &r)
{
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```







# 五、数学

## 1、乘法逆元

### 求多个（p为质数）

```c++
const int mod;
int inv[N];

void init(){
	inv[1]=1;
    for(int i=2;i<=n;++i) inv[i]=(mod-mod/i)*inv[mod%i]%mod;
}
```

### 求单个（p为质数）(容易爆)

```c++
const int mod;

int q_pow(int a,int b){
	int ans=1;
	for(;b;b>>=1){
		if(b&1) ans=ans*a%mod;
		a=a*a%mod;
	}
	return ans;
}

int inv(int x){
	return q_pow(x,mod-2);
}
```

### 求单个（任意）

```c++
const int mod;
int a,x,y;

int exgcd(int a,int p,int &x,int &y){
	int tmp=a;
	if(!p){
		x=1;y=0;
		return tmp;
	}
	tmp=exgcd(p,a%p,y,x);
	y-=(a/p)*x;
	return tmp;
}

int inv(int a){
    exgcd(a,mod,x,y);
    return (x+mod)%mod;
}
```



## 2、扩展欧几里得

```c++
//解方程a∗x+b∗y=gcd(a,b)
int exgcd(int a,int b,int &x,int &y){
	int tmp=a;
	if(!b){
		x=1;y=0;
		return tmp;
	}
	tmp=exgcd(b,a%b,y,x);
	y-=(a/b)*x;
	return tmp;
}

int c=exgcd(a,b,x,y);
```

### 求同余方程

$$
求解ax \equiv c (mod p)
$$

```c++
int exgcd(int a,int p,int &x,int &y){
	int tmp=a;
	if(!p){
		x=1;y=0;
		return tmp;
	}
	tmp=exgcd(p,a%p,y,x);
	y-=(a/p)*x;
	return tmp;
}

// x=((x+p)%p*c)%p;
```



## 3、素数筛

### 埃氏筛

```c++
int prime[N],cnt;
bool st[N];

void get_primes(int x) {
    for(int i=2;i<=x;++i){
        if(!st[i]){
            prime[cnt++]=x;
            for(int j=i*i;j<=x;j+=i) st[j]=true;
        }
    }
}
```

### 线性筛

```c++
int prime[N],cnt;
bool st[N];

void get_primes(int x){
    for(int i=2;i<=n;++i){
        if(!st[i]) prime[cnt++]=i;
        for(int j=0;prime[j]<=n/i;++j){
            st[prime[j]*i]=true;
            if(i%prime[j]==0) break;
        }
    }
}
```

### -1.试除法判定**质数**

```cpp
bool is_prime(int n){
    if(n < 2) return false;
    for(int i = 2;i <= n / i;i ++){
        //i <= n / i:防止越界，速度大于 i < sqrt(n)
        if(n % i == 0){
            return false;
        }
    }
    return true;
}
```



### 2.分解质因数

- x 的质因子最多只包含一个大于 根号x 的质数。如果有两个，这两个因子的乘积就会大于 x，矛盾。
- i 从 2 遍历到 根号x。 用 x / i，如果余数为 0，则 i 是一个质因子。
- s 表示质因子 i 的指数，x /= i 为 0，则 s++， x = x / i 。
  最后检查是否有大于 根号x 的质因子，如果有，输出。

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )//i <= x / i:防止越界，速度大于 i < sqrt(x)
        if (x % i == 0)//i为底数
        {
            int s = 0;//s为指数
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;//输出
        }
    if (x > 1) cout << x << ' ' << 1 << endl;//如果x还有剩余，单独处理
    cout << endl;
}

int main()
{
    int n;
    cin >> n;
    while (n -- )
    {
        int x;
        cin >> x;
        divide(x);
    }

    return 0;
}

 
```



### 



## 4、中国剩余定理

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int N=1e5+8;
int n,a[N],p[N],mul=1,x,y,res,mod;

int exgcd(int c,int p,int &x,int &y){
	int tmp=c;
	if(!p){
		x=1;y=0;
		return tmp;
	}
	tmp=exgcd(p,c%p,y,x);
	y-=(c/p)*x;
	return tmp;
}

int inv(int t){
    int tmp=exgcd(t,mod,x,y);
    return (x+mod)%mod;
}

signed main(){
	ios::sync_with_stdio(false);
    cin.tie(0);
    cin>>n;
    for(int i=1;i<=n;++i) cin>>p[i]>>a[i],mul*=p[i];
    for(int i=1;i<=n;++i){
    	int t=mul/p[i];
    	mod=p[i];
    	res+=a[i]*t*inv(t);
	}
	cout<<res%mul<<endl;
}
```



## 5、卡特兰数

### 递归定义

$$
f_n=f_0*f_{n-1} +f_1*f_{n-2}+...f_{n-1}*f_0  \qquad n\ge2
$$

### 递推关系

$$
f_n=\frac{4n-2}{n+1}f_{n-1}
$$

### 通项公式

$$
f_n=\frac{1}{n+1}C^n_{2n}\\
f_n=C^n_{2n}-C^{n-1}_{2n}
$$



## 6、欧拉函数

$$
\varphi(n)=n\prod_{p|n}(1-\frac{1}{p})
$$

求1~n中每个数的欧拉函数之和。

//线性筛法同时求欧拉函数

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1000010;
int primes[N], cnt;
int phi[N];
bool st[N];
void get_eulers(int n)
{
    phi[1] = 1;//!
    for (int i = 2; i <= n; i++)
    {
        if (!st[i])
        {
            primes[cnt++] = i;
            phi[i] = i - 1; 
        }
        for (int j = 0; primes[j] <= n / i; j++)
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0)
            {
                phi[primes[j] * i] = phi[i] * primes[j]; 
                break;
            }
            phi[primes[j] * i] = phi[i] * (primes[j] - 1);
        }
    }
}
int main()
{
    int n;cin >> n;
    get_eulers(n);
    LL res = 0;
    for (int i = 1; i <= n; i++) res += phi[i];
    printf("%lld\n", res);

    return 0;
}
```





## 7、组合数

### 递归法（N<3000）

```c++
    // c[a][b] 表示从a个苹果中选b个的方案数
    for(int i=0;i<N;i++)
        for (int j=0;j<=i;j++)
            if(!j) c[i][j]=1;
            else c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
```

#### 1.O(n^2)//递推

$$
C_a^b =C_{a-1}^{b-1}+C_{a-1}^b   \quad ,\quad O(n^2)
$$

 ```cpp
#include<iostream>
using namespace std;
const int mod = 1e9+7;
long long f[2010] [2010];
int main()
{
    //预处理
    for(int i=0;i<=2000;i++)
    {
        for(int j=0;j<=i;j++)
        {
            if(!j) f[i] [j] =1;
            else f[i] [j]=(f[i-1] [j-1]+f[i-1] [j])%mod;
        }
    }
    int n;
    cin>>n;
    while(n--)
    {
        int a,b;
        cin>>a>>b;
        printf("%ld\n",f[a] [b]);
    }
}

 
 ```

#### 2.快速幂求组合数 O(a∗log(mod))

```cpp
#include<iostream>
using namespace std;
const int mod=1e9+7,N=1e5+10;
typedef long long LL;
long long fac[N],infac[N];
int quick_pow(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
int main()
{
    int n;
    fac[0]=infac[0]=1;
    for(int i=1;i<=1e5;i++)
    {
        fac[i]=fac[i-1]*i%mod;
        infac[i]=(LL)infac[i - 1] * quick_pow(i,mod-2,mod)%mod;
    }
    cin>>n;
    while(n--)
    {
        int a,b;
        cin>>a>>b;
        cout<<(LL)fac[a] * infac[b] % mod * infac[a - b] % mod<<endl;
    }
}

 
```



## 8.Nim

```markdown
NIM博弈不存在平局，只有先手必胜和先手必败两种情况。

定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An != 0
```





#  



# 七、动态规划

##  背包九讲

#### 1.01背包

朴素版$O(nv)$

`f[i][j]`：前i个物品，总体积是j的情况下，总价值的最大值

​		result=max(f[n] [0~v])

1.不选第i个物品 `f[i][j]=f[i-1][j];`

2.选第i个物品 `f[i][j]=f[i-1][j-v[i]];`

-> `f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]);`

初始化: `f[0][0]=0;`

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1010;
int n,m;
int f[N][N];
int v[N],w[N];

int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>v[i]>>w[i];
    }
    for(int i=1;i<=n;i++){
        for(int j=0;j<=m;j++){
            f[i][j]=f[i-1][j];
            if(j>=v[i]){
			f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i]);
            }
		}
    }
    int res=0;
    for(int i=0;i<=m;i++){
		res=max(res,f[n][i]);
    }
    cout<<res<<endl;
}
```

//滚动数组？

压缩到一维

```cpp
 for(int i=1;i<=n;i++){
        for(int j=m;j>v[i];j--){
            //??? 
            //逆序是为了保证更新当前状态时
            //用到的状态是上一轮的状态，保证每个物品只有一次或零次;
			f[j]=max(f[j],f[j-v[i]]+w[i]);
		}
  }
//初始化f[i]=0;	
  cout<<f[m];
```

tip:

​	如果这里初始化为`f[0]=0,f[i]=-INF,i!=0;`的话，`ans=max{f[0...m]};`



#### 2.完全背包

//每件物品可以选无限次

`f[i]` 总体积是i的情况下，最大价值是多少

ans=max{f[0.....m]}

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1010;
int n,m;
int f[N];

int main(){
    cin>>n>>m;
    int v=0,w=0;
    for(int i=1;i<=n;i++){
        cin>>v>>w;
         for(int j=v ;j<=m;j++){
			f[j]=max(f[j],f[j-v]+w);
		}
    }
     
//初始化f[i]=0;	
  cout<<f[m];
}
```

> 首先dp数组初始化全为0：给定物品种类有4种，包最大体积为5，数据来源于题目的输入
> v[1] = 1, w[1] = 2
> v[2] = 2, w[2] = 4
> v[3] = 3, w[3] = 4
> v[4] = 4, w[4] = 5
>
> - i = 1 时： j从v[1]到5
>   dp[1] = max(dp[1],dp[0]+w[1]) = w[1] = 2 (用了一件物品1）
>   dp[2] = max(dp[2],dp[1]+w[1]) = w[1] + w[1] = 4（用了两件物品1）
>   dp[3] = max(dp[3],dp[2]+w[1]) = w[1] + w[1] + w[1] = 6（用了三件物品1）
>   dp[4] = max(dp[4],dp[3]+w[1]) = w[1] + w[1] + w[1] + w[1] = 8（用了四件物品1）
>   dp[5] = max(dp[3],dp[2]+w[1]) = w[1] + w[1] + w[1] + w[1] + w[1] = 10（用了五件物品）
>
> 
>
> - i = 2 时：j从v[2]到5
>   dp[2] = max(dp[2],dp[0]+w[2]) = w[1] + w[1] = w[2] =  4（用了两件物品1或者一件物品2）
>   dp[3] = max(dp[3],dp[1]+w[2]) = 3 * w[1] = w[1] + w[2] =  6（用了三件物品1，或者一件物品1和一件物品2）
>   dp[4] = max(dp[4],dp[2]+w[2]) = 4 * w[1] = dp[2] + w[2] =  8（用了四件物品1或者，两件物品1和一件物品2或两件物品2）
>   dp[5] = max(dp[5],dp[3]+w[2]) = 5 * w[1] = dp[3] + w[2] =  10（用了五件物品1或者，三件物品1和一件物品2或一件物品1和两件物品2）
>
> 
>
> - i = 3时：j从v[3]到5
>   dp[3] = max(dp[3],dp[0]+w[3]) = dp[3] = 6 # 保持第二轮的状态 
>   dp[4] = max(dp[4],dp[1]+w[3]) = dp[4] = 8 # 保持第二轮的状态 
>   dp[5] = max(dp[5],dp[2]+w[3]) = dp[4] = 10 # 保持第二轮的状态
>
> 
>
> - i = 4时：j从v[4]到5
>   dp[4] = max(dp[4],dp[0]+w[4]) = dp[4] = 10 # 保持第三轮的状态
>   dp[5] = max(dp[5],dp[1]+w[4]) = dp[5] = 10 # 保持第三轮的状态
>
> 上面模拟了完全背包的全部过程，也可以看出，最后一轮的dp[m]即为最终的返回结果。



#### 3.多重背包

//每个物品有个数限制(假如第 $i$ 个物品有 $s_i$ 个)；

##### (1.朴素版（三个for) $O(n^3)$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1010;
int n,m;
int f[N] ;

int main(){
    cin>>n>>m;
    int v=0,w=0,s=0;
    for(int i=1;i<=n;i++){
        cin>>v>>w>>s;
         for(int j=m ;j>=0;j--){
             //这里写成 j>=v 也可以
			 for(int k=0;k<=s&&k*v<=j;k++){
           		 f[j]=max(f[j],f[j-k*v]+w*k);
       		 }
		}
    }
    cout<<f[m];
}
```

##### [优化](https://blog.csdn.net/weixin_46503238/article/details/115132242?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167993493216800226531771%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167993493216800226531771&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-115132242-null-null.142^v76^control,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85&spm=1018.2226.3001.4187)

1.直接拆分：

- 拆成01背包



##### (2.二进制拆分$O(V*Σlog n[i])$

**原理**:
 一个数字，我们可以按照二进制来分解为1 + 2 + 4 + 8 …… +2^n + 余数

>十进制数字7,可以从二进制100,010,001做加和得到即111,001为1,010为2,100为4,也就是1、2、4,用1、2、4可以表示1~7中任意一个数。
>再比如,10,可以分为1,2,4,3这个三是怎么来的呢? 3就是余数!

通过上述原理,我们可以把第i件物品的s件,按二进制思想分为1,2,4…到剩余。这样从复杂度为s,降到了$O(log_2S)$。最后的复杂度为$O(V*Σlog n[i])$,这样就快了许多!



```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1000005;
int n,m;
int dp[N] ,v[N],w[N];

int main(){
    int cnt=0; 
    cin>>n>>m;
    for(int i=0;i<n;i++){
        int vv,ww,s;//体积，价值，数量
        cin>>vv>>ww>>s;
         //将s件用二进制转换为log_2s堆
        for(int k=1;k<=s;k<<=1){
            v[++cnt]=k*vv;
            w[cnt]=k*ww;
            s-=k;
        }
        if(s){//s有剩余,自立为新品种
		  v[++cnt]=s*vv;
           w[cnt]=s*ww;
        }
    }
    //01bag
    for(int i=1;i<=cnt;i++){
        for(int j=m;j>=v[i];j--){
            dp[j]=max(dp[j],dp[j-v[i]]+w[i]);
        }
    }
    cout<<dp[m];
}
```

yxc

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 12010, M = 2010;

int n, m;
int v[N], w[N];
int f[M];

int main()
{
    cin >> n >> m;

    int cnt = 0;
    for (int i = 1; i <= n; i ++ )
    {
        int a, b, s;
        cin >> a >> b >> s;
        int k = 1;
        while (k <= s)
        {
            v[++cnt] = a * k;
            w[cnt] = b * k;
            s -= k;
            k *= 2;
        }
        if (s > 0){ v[++cnt] = a * s;w[cnt] = b * s;}
        
    }
    n = cnt;
    for (int i = 1; i <= n; i ++ )
        for (int j = m; j >= v[i]; j -- )
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    cout << f[m] << endl;
    return 0;
}

```

vector

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2010;
int n, m;
int f[N];

struct Good // 定义结构体商品
{
    int v, w; // 每个商品的体积和价值
};

vector<Good> goods; // 设置vector数组存储每个商品

int main()
{
    cin >> n >> m; // n件物品和体积为m的背包
    for (int i = 0; i < n; i ++ )
    {
        int v, w, s; // 体积，价值，个数
        cin >> v >> w >> s;
        for (int k = 1; k <= s; k *= 2) // 进行2进制优化
        {
            s -= k; // 将s进行拆解，拆到比k小为止，拆成2的整数次幂
            goods.push_back({v * k, w * k}); // 放入商品当中
        }
        if (s > 0) goods.push_back({v * s, w * s});
        // 如果s还有剩下的，就把它本身放进去
    }

    // 拆解完成，进行最终目的：01背包！
    for (auto good : goods) 
        for (int j = m; j >= good.v; j -- )
            f[j] = max(f[j], f[j - good.v] + good.w);

    cout << f[m] << endl;

    return 0;
}

 
```



##### (3[.单调队列](https://blog.csdn.net/weixin_46503238/article/details/115179020?spm=1001.2014.3001.5502)(究极版)$O(nm)$



 ```cpp
    for(int i=1;i<=n;i++)
    {
        memcpy(g,f,sizeof(f));//将数组f拷贝到g中
        int v,w,s;//体积、价值、件数
        scanf("%d%d%d",&v,&w,&s);
        //按照体积分为v类,每个类起点为0,1,....v-1
        for(int j=0;j<v;j++)
        {
            int head=0,tail=-1;
            //遍历整个类
            for(int k=j;k<=m;k+=v)
            {
                //利用单调队列滑动窗口模板
                if(head<=tail&&k-s*v>q[head]) head++;
                //队首元素,不在于滑动窗口,踢出队首元素
                //将在滑动区间内,中最大值,也就是单调队列中队首元素
                if(head<=tail) 
                    f[k]=max(g[k],g[q[head]]+(k-q[head])/v*w);
                //01背包动态转移方程
                //如果队尾元素小于g[k],则从队尾出队
                while(head<=tail&&g[k]>=g[q[tail]]+(k-q[tail])/v*w) 
                    tail--;
                //g[k]入队
                q[++tail]=k;
            }
        }
    }
    


 ```

根据上面的过程,我们可以概况几个步骤.
 1、将f数组复制到g中
 2、在同一物品时,将整个背包分类
 3、遍历整个类
 4、判断单调队列队首元素,是否在窗口中
 5、给f[k]赋值,执行动态转移方程
 6、维护单调队列,g[k]+v(v是简写)与队尾元素依次比较
 7、g[k]入队



==代码细节讲解:==

` int head=0,tail=-1;`

> 首先单调队列是一个数组,我们用两个int型变量head,和tail来维护队头和队尾

  `if(head<=tail&&k-s*v>q[head]) head++;//队首元素,不在于滑动窗口,踢出队首元素`

>解释:k-s*v>q[head] 大家知道q是单调队列,它存到是g数组的下标,当队头元素是g[q[head]],不在新的窗口中,那么需要出队,当前元素的下标为k,窗口大小为:件数x体积也就是s✖v,那么k-s✖v>q[head]时候,q[head]也就不在窗口中!(大家动手写一下就会了)



`if(head<=tail) f[k]=max(g[k],g[q[head]]+(k-q[head])/v*w);//01背包动态转移方程`

>这条语句,就是更新f[k],就是动态转移方程!注意max()中为g[k],不是f[k]



`while(head<=tail&&g[k]>=g[q[tail]]+(k-q[tail])/v*w) tail--;`

>我对g[k]>=g[q[tail]]+(k-q[tail])/v*w,这个不等式进行讲解。
>因为每次我都需要g[k]入队,那么在入队前我要维护单调队列,如果队尾元素的值小于g[k]+v,那么需要队尾需要出队!
>比如要更更新的为f[x],那么我如何比较呢?
>{(x-k)/v是件数}
>g[k]+(x-k)/v✖w>=g[q[tail]]+(x-q[t])/v✖w
>我们对不等式进行整理,就可以得到
>g[k]>=g[q[tail]]+(k-q[tail])/v✖w

到这里,单调队列优化多重背包就讲解完毕

 

#### 4.混合背包

（01bag，完全bag，多重bag

物品一共有三类：

- 第一类物品只能用1次（01背包）；

- 第二类物品可以用无限次（完全背包）；

- 第三类物品最多只能用 *s i*次（多重背包）；

- 每种体积是 *v i*，价值是 *w i*

   

  求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
   输出最大价值。

```cpp
#include<bits/stdc++.h>
using namespace std;
//#define int long long
#define ll long long
const int maxn=2010;
const int N=2e9+10;
int f[maxn];
int n,m;
struct Thing{
	int kind;
	int v,w;
};
vector<Thing> things; 
int main()
{ 
	cin>>n>>m;
	for(int i=0;i<n;i++){
		int v,w,s;
		cin>>v>>w>>s;
		if(s<0)things.push_back({-1,v,w}); //01
		else if(s==0){					   //完全 
			things.push_back({0,v,w});
		}else{							   //多重 
		     //拆成01背包，二进制优化 
			for(int k=1;k<=s;k<<=1){
				s-=k;
				things.push_back({-1,v*k,w*k});
			}
			if(s){
				things.push_back({-1,v*s,w*s});
			}
			
		}
	}
	for(auto thing:things){
		if(thing.kind<0){
			for(int j=m;j>=thing.v;j--){
				f[j]=max(f[j],f[j-thing.v]+thing.w);
			}
		}else {
			for(int j=thing.v;j<=m;j++){
				f[j]=max(f[j],f[j-thing.v]+thing.w);
			}
		}
	}
	cout<<f[m]; 
	return 0;
}
```



#### 5.二维费用背包

//01

限制条件增加，多考虑物品的重量

`f[i][j][k]` : 从前 i 个物品选，总体积不超过 j ，重量不超过 k 时的价值最大值；

状态计算：

- 不选第 i 个 ： `f[i][j][k]=f[i-1][j][k];`
- 选第 i 个 ： `f[i-1][j-w1[i]][k-w2[i]]+v[i];`

--> 状态转移方程：`f[i][j][k] = max (f[i][j][k],f[i - 1][j - w1][k- w2] + v);`

==由于只用到了上一面信息（因为是二维），所以可以使用滚动数组优化。==

`f[j1][j2] = max (f[j1][j2],f[j1 - w1][j2 - w2] + v);`

```cpp
#include <iostream>
using namespace std;
const int N = 110;
int n,m1,m2;
int f[N][N];
int main () {
    cin >> n >> m1 >> m2;
    for (int i = 1;i <= n;i++) {
        int w1,w2,v;
        cin >> w1 >> w2 >> v;
        for (int j1 = m1;j1 >= w1;j1--) {
            for (int j2 = m2;j2 >= w2;j2--)
                f[j1][j2] = max (f[j1][j2],f[j1 - w1][j2 - w2] + v);
        }
    }
    cout << f[m1][m2] << endl;
    return 0;
}

```





#### 6.分组背包

有 *N* 组物品和一个容量是 *V*的背包。

每组物品有若干个，同一组内的物品最多只能选一个。
 每件物品的体积是 $v_{ij}$，价值是 $ w_{ij}$，其中 *i* 是组号，*j*是组内编号。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。

->key

与01bag类似

- 对于每组 s 个物品，有 s+1 种选法：$f_j=max(f_j,f_{j−v_0}+w_0,f_{j−v1}+w_1,…,f_{j−v_s}+w_s) $就是说可以不选（选 0 个），选 1 个，选 2 个…选 s个
- 所以，我们先循环枚举所有体积，再循环枚举所有选择，最后得出状态转移方程：$f_j=max(f_j,f_{j−vk}+w_k)$
  ，其中 k 是枚举所有选择中的循环变量

```cpp
#include<bits/stdc++.h>
using namespace std;

int v[105],w[105],f[105];

int main()
{
    int n,m; //输入物品组数与背包容量

    scanf("%d%d",&n,&m);

    for(int i=1;i<=n;i++)
    {
        int s;
        scanf("%d",&s); //输入第i个物品组的物品数量

        for(int j=1;j<=s;j++) scanf("%d%d",&v[j],&w[j]);
        //输入每个物品的体积和价值

        //接下来是处理过程

        for(int j=m+1;j>=1;j--) //枚举所有体积
            for(int k=1;k<=s;k++) //枚举所有选择
                if(j>=v[k]) //必须要满足，否则下面的下标减出来是负数
                    f[j]=max(f[j]/*不选*/,f[j-v[k]]+w[k]/*选*/);
    }
    printf("%d",f[m]);

    return 0;
}

 
```



#### 7.*背包问题求方案数



#### 8.求背包问题的方案



#### 9.有依赖的背包



## 十-杂题

### 约舍夫环

*n*个人围成一圈，编号分别为1∼*n*。

第一个人从1开始报数，报m的退出队列，下一个人接着从1开始报。

如此反复，最后剩下一个，求最后的胜利者的编号。



1.公式

~~~cpp
#include<bits/stdc++.h>
using namespace std;
int aa,b,c,ans;  

void Joscircle(int n, int k, int m)
{//n 总人数，k从第几个人开始报数，m：报数间隔
     for(int i=2;i<=n;i++){
     	 ans=(ans+m)%i;  
     }
      cout<<ans+1<<endl;
    //ans为最后一个死亡的人，ta的下一个才是胜利者
    
}
int main()
{
    cin>>aa>>c;
    Joscircle(aa,1,c);
    return 0;
}
~~~



