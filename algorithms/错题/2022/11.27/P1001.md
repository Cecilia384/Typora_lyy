`Komorebi`最近迷上了叠硬币的游戏。他先放一枚硬币在桌上，然后一枚一枚地往上堆，看能最多放几枚而不倒。

随着不断训练，`Komorebi`的技术也不断精进，但由于这样玩很费时间，很快他厌倦了这样的玩法。于是他想出了另一种玩法，先把硬币堆成一个个小堆，然后再把这些小堆叠起来，看最多能叠多高。

玩着玩着，`Komorebi`突发奇想：对于n*n*个硬币堆，如果想选取一些硬币堆，一堆一堆地叠起来，将它们叠到正好H*H*个硬币那样高（不可以随意增加或减少每个硬币堆的硬币数量），最少需要几个硬币堆呢？由于硬币堆太多了，他有些糊涂了，请你帮帮他吧！

### 输入格式

![img](P1001.assets/AE%25R6Q%5B12VB1SK_X%5B%5B@%5BA%25M-16695570042851.png)

### 输出格式

下面输出m*m*个数代表该硬币堆的高度，并且方案按高度升序输出。如果有多个满足要求的方案（且都已按高度升序排列），则输出字典序最小的那个方案（如有两个长度都为m*m*的序列`A`和`B`，若A_i=B_i,i=1,2,3,…,s(s<m)*A**i*=*B**i*,*i*=1,2,3,…,*s*(*s*<*m*)，且A_{i+1}<B_{i+1}*A**i*+1<*B**i*+1，则认为序列`A`按字典序小于序列`B`）。如果没有任何一种方案可以正好达到高度H*H*，就输出-1−1。

### 样例输入1

```none
5 10
7 8 2 3 5
```

[Copy](javascript:;)

### 样例输出1

```none
2
2 8
```

[Copy](javascript:;)

### 数据范围与提示

<img src="P1001.assets/%60SZDG2MY8W@%60$8BF$HIZ%7DXD.png" alt="img" style="zoom:50%;" />



魏佬题解

http://202.120.222.93:8888/p/P1001/solution/63832a6e4d4b84e0b23eece1


![img](http://cn.gravatar.com/avatar/d41d8cd98f00b204e9800998ecf8427e?d=mm&s=64) [魏秋桐 (2135061624usstlanqiaotest2022) ](http://202.120.222.93:8888/user/23)[LV 10](http://202.120.222.93:8888/user/23) @ 4 小时前

[ ](javascript:;)

### [P1001 叠硬币](http://202.120.222.93:8888/p/P1001?tid=637f09df5b9d3012df029a5c)

01 背包问题求具体方案 时间复杂度 :O(nH)

做这道题的前提 :**会做 01 背包问题**

把H看作背包容量， h*i 看作物品体积，每一个硬币堆的价值都为 1 ,因为每个硬币堆只能用一次， 这样就是一个典型的 01背包问题了。

**题目要求**： 求最少需要多少个硬币堆 ， 以及输出字典序最小的方案。

**求最小需要多少个硬币堆**： 其实就是价值最小 (与标准的01背包问题相反) ，我们就初始化 dp 数组为一个很大的值，状态计算的时候求最小值就行。如果答案不存在 ，那么 dp[n] [m] 一定没有被更新过 ， 那么只需判断 dp[n] [m]  是否 大于 n

**接下来是求具体方案**

我们先来看一下背包问题求方案数如何解决的

对于最后一个物品(用下标 i*i* 表示) ，价值为 w[i]*w*[*i*] , 重量为 v[i]*v*[*i*] 是否选择， 我们要找到 dp[i] [m] ， 根据转移方程

dp[i] [j] = min(dp[i] [j] , dp[i - 1] [j - v[i]] + w[i])

如果我们选择了这个物品， 那么一定有

dp[i] [m] = dp[i] [m - v[i]] + w[i]

且背包剩余体积变成了 m = m - v[i]

那么对于倒数第二个物品 (用 i - 1表示) 是否选择 ，则判断是否成立即可

dp[ i - 1] [m] = dp[ i - 2] [m - v[i - 1]] + w[i - 1]

根据上述规律，i从 n 循环到 1即可得出 从 1 - n中哪些物品是被选择的

[背包问题求具体方案模板题](https://www.acwing.com/problem/content/description/12/)

------

我们再回到这个问题 ， 只需要把上述方程的 w[i]*w*[*i*]看作 11 即可 。

但是还有一个问题 , **如何求字典序最小的方案 ？** 其实这个也很好想 ， 因为我们最先判断的是第 n*n* 个物品是否选择 ， 那我们在最开始状态计算之前， 把物品从大到小排序即可。

**Accept代码**

~~~c++
#include<bits/stdc++.h>

using namespace std;

const int N = 3010;

int n , m;
int h[N] , f[N][N];

int main()
{
	// 提高cin速率
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	
	cin >> n >> m ;
	for(int i = 1 ; i <= n ; i ++ )
		cin >> h[i];
	
	memset(f , 0x3f , sizeof f);
	f[0][0] = 0 ;
	
	sort(h + 1 , h + n + 1 , greater<int>());
	
	for(int i = 1 ; i <= n ; i ++ )
		for(int j = 0 ; j <= m ; j ++ )
		{
			f[i][j] = f[i - 1][j];//不选第 i 堆
			if(j >= h[i])
				f[i][j] = min(f[i][j] , f[i - 1][j - h[i]] + 1);
             //选第 i 堆
		}
	
	if(f[n][m] > n)cout << "-1\n";
	else
	{
		cout << f[n][m] << "\n";
		int res = m ;
		for(int i = n ; i ; i -- )
			if(f[i][res] == f[i - 1][res - h[i]] + 1)
				res -= h[i] , cout << h[i] << " ";
		cout << "\n";
	}
	
	return 0;
}

~~~

