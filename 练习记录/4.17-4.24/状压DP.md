典型例题

[AcWing 291. 蒙德里安的梦想](https://www.acwing.com/solution/content/28088/)

**棋盘式状态压缩DP**

由于长宽都比较小，采用**棋盘式状态压缩DP**解决，此类任务一般是在棋盘内填各种形状的块，然后求方案数。

核心思想是：总方案数等于合法横向摆放小矩形方案数之和。下面的图形中，绿色为横向填充，黄色为纵向填充，图1是合法的，图2则是非法的。



`f[i][j]`表示：前i-1列已经摆放完毕(不能再改了)，当前要对第i列进行横向小长方形的摆放，且前一列伸出一个小方格是j 的情况下的方案数。如下图所示：

`f[i][j]`记录的是集合中的方案总数(根据题目所求来确定)

接下来考虑如何进行状态计算(转移)，所谓状态计算，就是对集合进行划分，而划分的依据就是“最后一个不同点”。根据我们上面`f[i][j]`的定义，第i-1列横向小长方形的摆放方案是确定的(因为二进制数j代表了其摆放的情况)，所以，最后一个不同点就是第i-2列的摆放情况。因此，我们将依据第i-2列的摆放情况对`f[i][j]`所表示的大集合进行划分，将它划分成1<<n个子集。但是，这些子集不一定都可以转移过来，因此，我们需要判断哪些子集所对应的状态才可以转移到我们当前的状态。为了方便之后的表示，我们设a为第i-1列的“摆放情况”，b为第i-2列的”摆放情况”。那么，合法的状态需要满足以下两个条件：1：`a&b==0`,即二者的二进制不能有某一位同时为1(意思是第i-2列和第i-1列不能在同一行同时摆放上横向的小长方形(同时伸出小格子)，因为这样，第i-2列伸出的小方格就会”阻碍”到第i-1列的摆放，是不合法的)

2: 由于第`i-1`列横向的格子已经摆放完毕，那么其纵向格子的摆放方式也已经确定，所以，我们摆完横向的小长方形后，剩下连续的空格子的数量不能是奇数，否则就不能通过摆放纵向小长方形将整个棋盘填满了。所以，我们需要算出每个状态下连续0的个数。这个条件的判断可以通过”预处理完成”。

另外，我们可以预处理出所有合法(能够进行状态转移的状态),方便后续状态的计算。

这样，`f[i][j]`就等于所有能转移到它的状态所对应的方案数的总和。

我们最终的答案就是:`f[m][0]`。注意，下标从0开始，所以，它代表所有前m–1列(也就是整个棋盘)已经摆完，并且伸出格子的情况为0(没有伸出棋盘，是合法的)的方案总数。并且，dp数组的初始化为：`f[0][0]=1`(因为摆第0列时不存在前一列会伸出来，也就表示当前列没有横着摆的小长方形，所以只有都竖着摆放这一种情况)



```cpp
#include <bits/stdc++.h>
using namespace std;


const int N = 12, M = 1<< N;  

long long f[N][M] ;// 第一维表示列， 第二维表示所有可能的状态

bool st[M];  //存储每种状态是否有奇数个连续的0，如果奇数个0是无效状态，如果是偶数个零置为true。

//vector<int > state[M];  //二维数组记录合法的状态
vector<vector<int>> state(M);  //两种写法等价:二维数组

int m, n;

int main() {

    while (cin >> n >> m, n || m) { //读入n和m，并且不是两个0即合法输入就继续读入

        //第一部分：预处理1
        //对于每种状态，先预处理每列不能有奇数个连续的0

        for(int i = 0; i < (1 << n); i ++) {

            int cnt = 0 ;//记录连续的0的个数

            bool isValid = true; // 某种状态没有奇数个连续的0则标记为true

            for(int j = 0; j < n; j ++) { //遍历这一列，从上到下

                 if ( (i >> j) & 1) {  
                     //i >> j位运算，表示i（i在此处是一种状态）的二进制数的第j位； 
                     // &1为判断该位是否为1，如果为1进入if
                    if (cnt & 1) { 
                    //这一位为1，看前面连续的0的个数，如果是奇数（cnt &1为真）则该状态不合法
                        isValid =false; break;
                    } 

                    cnt = 0;
                     // 既然该位是1，并且前面不是奇数个0（经过上面的if判断），计数器清零。
                    //其实清不清零没有影响
                 }
                 else cnt ++; //否则的话该位还是0，则统计连续0的计数器++。
            }
            if (cnt & 1)  isValid = false; //最下面的那一段判断一下连续的0的个数

            st[i]  = isValid; //状态i是否有奇数个连续的0的情况,输入到数组st中
        }

        //第二部分：预处理2
        // 经过上面每种状态 连续0的判断，已经筛掉一些状态。
        //下面来看进一步的判断：看第i-2列伸出来的和第i-1列伸出去的是否冲突

        for (int j = 0; j < (1 << n); j ++) { //对于第i列的所有状态
            state[j].clear(); //清空上次操作遗留的状态，防止影响本次状态。

            for (int k = 0; k < (1 << n); k ++) { //对于第i-1列所有状态
                if ((j & k ) == 0 && st[ j | k]) 
                // 第i-2列伸出来的 和第i-1列伸出来的不冲突(不在同一行) 
                //解释一下st[j | k] 
                //已经知道st[]数组表示的是这一列没有连续奇数个0的情况，
                //我们要考虑的是第i-1列（第i-1列是这里的主体）中从第i-2列横插过来的，
                //还要考虑自己这一列（i-1列）横插到第i列的
                //比如 第i-2列插过来的是k=10101，第i-1列插出去到第i列的是 j =01000，
                //那么合在第i-1列，到底有多少个1呢？
                //自然想到的就是这两个操作共同的结果：两个状态或。 
                    // j | k = 01000 | 10101 = 11101
                //这个 j|k 就是当前 第i-1列的到底有几个1，即哪几行是横着放格子的

                    state[j].push_back(k);  
                    //二维数组state[j]表示第j行， 
                    //j表示 第i列“真正”可行的状态，
                    //如果第i-1列的状态k和j不冲突则压入state数组中的第j行。
                    //“真正”可行是指：既没有前后两列伸进伸出的冲突；又没有连续奇数个0。
            }

        }

        //第三部分：dp开始

        memset(f, 0, sizeof f);  
        //全部初始化为0，因为是连续读入，这里是一个清空操作。
        //类似上面的state[j].clear()

        f[0][0] = 1 ;// 这里需要回忆状态表示的定义
        //按定义这里是：前第-1列都摆好，且从-1列到第0列伸出来的状态为0的方案数。
        //首先，这里没有-1列，最少也是0列。
        //其次，没有伸出来，即没有横着摆的。即这里第0列只有竖着摆这1种状态。

        for (int i = 1; i <= m; i ++) { //遍历每一列:第i列合法范围是(0~m-1列)
            for (int j = 0; j < (1<<n); j ++) {  //遍历当前列（第i列）所有状态j
                for (auto k : state[j])    // 遍历第i-1列的状态k，如果“真正”可行，就转移
                    f[i][j] += f[i-1][k];    // 当前列的方案数就等于之前的第i-1列所有状态k的累加。
            }
        }

        //最后答案
        //f[m][0]表示 前m-1列都处理完，并且第m-1列没有伸出来的所有方案数。
        //即整个棋盘处理完的方案数
        cout << f[m][0] << endl;
    }
}   
 
```





```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int N=12,M=1 << N;
int f[N][M];
bool st[M];
vector<vector<int> > state(M);
int n,m;
signed main() {
	while(cin>>n>>m,n||m) {
		for(int i=0; i<(1 << n); i++) {
			int cnt=0;
			bool isValid =true;
			for(int j=0; j<n; j++) {
				if((i>>j)&1) {
					if(cnt&1) {
						isValid=false;
						break;
					}
					cnt=0;
				} else {cnt++;}
			}
			if(cnt & 1) {isValid = false;}
			st[i]=isValid;
		}
		for(int j=0; j<(1 << n); j++) {
			state[j].clear();
			for(int k=0; k<(1<<n); k++) {
				if((j&k)==0 && st[j|k]) {
					state[j].push_back(k);
				}
			}
		}
		memset(f,0,sizeof f);
		f[0][0]=1;
		for(int i=1; i<=m; i++) {
			for(int j=0; j<(1<<n); j++) {
				for(auto k :state[j]) {
					f[i][j]+=f[i-1][k];
				}
			}
		}
	   cout<<f[m][0]<<endl;
	}
		return 0;
}

```



 