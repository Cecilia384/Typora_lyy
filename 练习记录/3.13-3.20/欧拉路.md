本页面将简要介绍欧拉图的概念、实现和应用。

## 定义

- **欧拉回路**：通过图中每条边恰好一次的回路
- **欧拉通路**：通过图中每条边恰好一次的通路
- **欧拉图**：具有欧拉回路的图
- **半欧拉图**：具有欧拉通路但不具有欧拉回路的图

欧拉路（一笔画）

1. **欧拉路径定义**：

图中经过所有边**恰好一次**的路径叫**欧拉路径**（也就是一笔画）。如果此路径的**起点**和**终点**相同，则称其为一条**欧拉回路**。

2. **欧拉路径判定（是否存在）**：

- **有向图欧拉路径**：图中**恰好**存在 1 个点出度比入度多  1（这个点即为  起点 S ），1 个点入度比出度多 1 （这个点即为终点 T ），其余节点出度=入度。
- **有向图欧拉回路**：**所有点**的入度=出度（起点 S  和终点 T* * 可以为任意点）。
- **无向图欧拉路径**：图中**恰好**存在 2  个点的度数是**奇数**，其余节点的度数为**偶数**，这两个度数为**奇数**的点即为欧拉路径的 **起点** S  和 **终点** T 。
- **无向图欧拉回路**：**所有点**的度数都是**偶数**（起点 S  和终点 T  可以为任意点）。、



# 【模板】欧拉路径

## 题目描述

求有向图字典序最小的欧拉路径。

## 输入格式

第一行两个整数 $n,m$ 表示有向图的点数和边数。

接下来 $m$ 行每行两个整数 $u,v$ 表示存在一条 $u\to v$ 的有向边。

## 输出格式

如果不存在欧拉路径，输出一行 `No`。

否则输出一行 $m+1$ 个数字，表示字典序最小的欧拉路径。

## 样例 #1

### 样例输入 #1

```
4 6
1 3
2 1
4 2
3 3
1 2
3 4
```

### 样例输出 #1

```
1 2 1 3 3 4 2
```

## 样例 #2

### 样例输入 #2

```
5 5
1 2
3 5
4 3
3 4
2 3
```

### 样例输出 #2

```
1 2 3 4 3 5
```

## 样例 #3

### 样例输入 #3

```
4 3
1 2
1 3
1 4
```

### 样例输出 #3

```
No
```

## 提示

对于 $50\%$ 的数据，$n,m\leq 10^3$。

对于 $100\%$ 的数据，$1\leq u,v\leq n\leq 10^5$，$m\leq 2\times 10^5$。

保证将有向边视为无向边后图连通。

[数据生成器](https://www.luogu.com.cn/paste/9oswk47n)



```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX=100010;
int n,m,u,v,del[MAX];
int du[MAX][2];//记录入度和出度 
stack <int> st;
vector <int> G[MAX];
void dfs(int now)
{
	for(int i=del[now];i<G[now].size();i=del[now])
	{ 
		del[now]=i+1;//把之前访问过的边标记 
		dfs(G[now][i]);
	}
	st.push(now);
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
        scanf("%d%d",&u,&v);
        G[u].push_back(v),du[u][1]++,du[v][0]++; 
    }  
    for(int i=1;i<=n;i++) sort(G[i].begin(),G[i].end());
    int S=1,cnt[2]={0,0}; //记录
    bool flag=1; //flag=1表示,所有的节点的入度都等于出度,
    for(int i=1;i<=n;i++)
	{
        if(du[i][1]!=du[i][0])
        {
            flag=0;
            if(du[i][1]-du[i][0]==1/*出度比入度多1*/) cnt[1]++,S=i;
            else if(du[i][0]-du[i][1]==1/*入度比出度多1*/) cnt[0]++;
            else return puts("No"),0;
        }
    }
    if((!flag)&&!(cnt[0]==cnt[1]&&cnt[0]==1)) return !puts("No"),0;
	//不满足欧拉回路的判定条件，也不满足欧拉路径的判定条件，直接输出"No" 
    dfs(S);
    while(!st.empty()) printf("%d ",st.top()),st.pop();
    return 0; 
}
```



# Hierholzer 算法

也称逐步插入回路法。

#### 过程

算法流程为从一条回路开始，每次任取一条目前回路中的点，将其替换为一条简单回路，以此寻找到一条欧拉回路。如果从路开始的话，就可以寻找到一条欧拉路。