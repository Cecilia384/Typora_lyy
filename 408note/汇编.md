### 1.显示字符

法一

```asm
DATA	SEGMENT	USE16 ;DATA	SEGMENT 定义数据段,USE16 指定使用 16 位模式。
STRING	DB	'H$'      ;STRING 定义字符串 'H', DB定义字节类型数据。
DATA	ENDS

CODE	SEGMENT	USE16
	ASSUME	CS:CODE,DS:DATA ;ASSUME：指定代码段和数据段的段寄存器。
BEG:	MOV	AX,DATA ;BEG：定义程序的入口点。
	  ;MOV AX, DATA：将数据段地址加载到 AX 寄存器中。
	MOV	DS,AX	;MOV DS, AX：将数据段地址存储在 DS 寄存器中。
	MOV	AH,9	;调用9号功能，打印字符串/将 9 存储在 AH 寄存器中
							;该寄存器是 DOS 中的系统调用功能号。
	MOV	DX,OFFSET STRING ;将字符串 "H" 的地址存储在 DX 寄存器中
	INT	21H		;执行 DOS 系统调用，将字符串打印到屏幕上。
	MOV	AH,4CH	;将程序退出的系统调用号 4CH 存储在 AH 寄存器中。
	INT	21H		;执行 DOS 系统调用，结束程序。
CODE	ENDS    ;代码段结束。
	END	BEG		;程序入口点结束。
 
```





`OFFSET`

在汇编语言中，`offset`是一个运算符，用于获取一个标号或变量的内存地址相对于其所在段的偏移量。在8086微处理器中，一个内存地址由一个段地址和一个偏移地址组成，`offset`运算符就是用来获取这个偏移地址的。

举个例子，假设我们在数据段中定义了一个变量`num`，那么可以使用`offset`运算符获取它的偏移地址：

```asm
.data
num dw 1234h

.code
mov ax, offset num ; 将num的偏移地址存入ax寄存器
```

在上面的代码中，`offset num`会被汇编器替换成`1234h`，因为`num`变量在数据段中的偏移地址正好是`1234h`。





法二

第二种方法：

;采用顺序编程方法，实现屏幕上显示大写字母A。

```asm
.486
CODE	SEGMENT	USE16
	ASSUME	CS:CODE
BEG:	MOV	AH,2	;2号功能显示一个字符DL=待显示的字符
	MOV	DL,41H	;或'A'
	INT	21H
	MOV	AH,4CH
	INT	21H
CODE	ENDS
	END	BEG
 
```



### 2.实验二

目的：学习间接寻址、数组和转移指令的用法

 ![img](%E6%B1%87%E7%BC%96.assets/8$O8BMR1FB93_$_Z2I8MWA.png)



实验报告要求

•三个问题分别写出源程序 

•对程序执行结果进行分析



 ![img](%E6%B1%87%E7%BC%96.assets/GZ9SKS4VLTVICD@I8%25%60KN90.png)

1

```asm
DATAS SEGMENT
    ;数据段开始
    ARRAY DB 31H, 36H, 33H, 32H, 38H, 37H, 35H, '$'
    ;定义一个字节数组ARRAY，内容为十六进制数31H, 36H, 33H, 32H, 38H, 37H, 35H，并以字符'$'结尾
DATAS ENDS
    ;数据段结束

STACKS SEGMENT
    ;堆栈段开始
    ;此处输入堆栈段代码
STACKS ENDS
    ;堆栈段结束

CODES SEGMENT
    ;代码段开始
    ASSUME CS:CODES,DS:DATAS,SS:STACKS
    ;设置代码段（CS）、数据段（DS）和堆栈段（SS）的段寄存器

START:
    ;程序入口
    MOV AX,DATAS
    MOV DS,AX
    ;将数据段的基地址移动到AX寄存器，然后将其值移动到DS段寄存器，以便访问数据段的内容

    ;此处输入代码段代码
    ;具体的代码逻辑，略去不表

    MOV SI, OFFSET ARRAY + 6
    ;将ARRAY的偏移量加上6的值移动到SI寄存器
    MOV CX, LENGTHOF ARRAY - 2
    ;将数组ARRAY的长度减去2的值移动到CX寄存器，用于控制循环次数
    MOV AL, [SI]
    ;将SI指向的数组元素值移动到AL寄存器

L1: 
    ;L1标签，用于循环
    MOV AH, [SI - 1]
    ;将SI指向的前一个数组元素值移动到AH寄存器
    MOV [SI], AH
    ;将AH寄存器的值移动到SI指向的数组元素位置
    DEC SI
    ;减小SI寄存器的值，使其指向前一个数组元素
    LOOP L1
    ;循环，判断CX寄存器的值是否为0，如果不为0则跳转到L1标签处继续循环
    MOV [SI], AL
    ;将AL寄存器的值移动到SI指向的数组元素位置

    LEA DX,ARRAY 
    MOV AH,09H
    INT 21H
    ;将数组ARRAY的地址移动到DX寄存器，将09H的值移动到AH寄存器，调用21H中断，在屏幕上显示数组内容

    MOV AH,4CH
    INT 21H
    ;将4CH的值移动到AH寄存器，调用21H中断，程序结束

CODES ENDS
    ;代码段结束
END START

```







ex1

```markdown
这段代码的主要思路是将一个字节数组中的元素循环右移一位。首先，在数据段中定义了一个名为 `ARRAY` 的字节数组，包含值 31H、36H、33H、32H、38H、37H、35H 和 '$'。

在代码段中，首先使用 `ASSUME` 指令指定各个寄存器的值，并将数据段的地址移到 `DS` 寄存器中。然后，将 `ARRAY` 变量的地址加上6（即指向数组倒数第二个元素）加载到 `SI` 寄存器中，并将数组长度减2（即不包括最后一个元素）加载到 `CX` 寄存器中。

接下来，进入一个循环，每次循环都将当前位置前一个元素的值移到当前位置，然后递减 `SI` 寄存器，指向前一个位置。循环执行直到处理完所有元素。

最后，将原来数组的最后一个元素（即循环右移前的第一个元素）存入数组的第一个位置。这样，整个数组就完成了循环右移一位的操作。

在完成循环右移操作后，代码使用DOS中断09H子功能输出移位后的数组。最后，使用DOS中断4CH子功能结束程序。
```



```asm
DATAS SEGMENT
    ;此处输入数据段代码 
    ARRAY DB 31H, 36H, 33H, 32H, 38H, 37H, 35H, '$'
DATAS ENDS

STACKS SEGMENT
    ;此处输入堆栈段代码
STACKS ENDS

CODES SEGMENT
    ASSUME CS:CODES,DS:DATAS,SS:STACKS
START:
    MOV AX,DATAS
    MOV DS,AX
    ;此处输入代码段代码
    ;LEA DX,ARRAY 
	;MOV AH,09H
	;INT 21H
    MOV SI, OFFSET ARRAY + 6
    MOV CX, LENGTHOF ARRAY - 2
    MOV AL, [SI]
L1: 
    MOV AH, [SI - 1]
    MOV [SI], AH
    DEC SI
    LOOP L1
    MOV [SI], AL
    
    LEA DX,ARRAY 
	MOV AH,09H
	INT 21H
    
    MOV AH,4CH
    INT 21H
CODES ENDS
    END START
```

ex2

```asm
DATAS SEGMENT
    ;此处输入数据段代码  
    ARRAY DB 34H, 33H, 37H, 32H, 38H, 39H, 31H
    MIN DB 0H
    MAX DB 0H
DATAS ENDS

STACKS SEGMENT
    ;此处输入堆栈段代码
STACKS ENDS

CODES SEGMENT
    ASSUME CS:CODES,DS:DATAS,SS:STACKS
START:
    MOV AX,DATAS
    MOV DS,AX
    ;此处输入代码段代码
    
    MOV SI, OFFSET ARRAY
    MOV CX, LENGTHOF ARRAY
    
    MOV AL, [SI]
    MOV AH, [SI]
    
FINDMAX:
	CMP AL, [SI]
	JC UPDATEMAX
	JMP FINDMIN
	
FINDMIN:
	CMP [SI], AH
	JC UPDATEMIN
	JMP NEXT
	
UPDATEMAX:
	MOV AL, [SI]
	JMP FINDMIN
	
UPDATEMIN:
	MOV AH, [SI]
	JMP NEXT
	
NEXT:
	INC SI
	LOOP FINDMAX
	
	MOV [MIN], AH
	MOV [MAX], AL
	
	MOV DL,[MIN]
    MOV AH,02H
    INT 21H
    
    MOV DL,20H
    MOV AH,02H
    INT 21H
    
    MOV DL,[MAX]
    MOV AH,02H
    INT 21H
    
    MOV AH,4CH
    INT 21H
CODES ENDS
    END START
```



```asm
DATAS SEGMENT; 定义数据段。
ARRAY DB 34H, 33H, 37H, 32H, 38H, 39H, 31H; 定义一个字节数组，包含值 34H、33H、37H、32H、38H、39H 和 31H。
MIN DB 0H; 定义一个字节变量，用于存储最小值。
MAX DB 0H; 定义一个字节变量，用于存储最大值。
DATAS ENDS; 结束数据段定义。

STACKS SEGMENT; 定义堆栈段。
STACKS ENDS; 结束堆栈段定义。

CODES SEGMENT; 定义代码段。
ASSUME CS:CODES,DS:DATAS,SS:STACKS; 使用 `ASSUME` 指令指定各个寄存器的值。
START:; 标记程序的起始位置。
MOV AX,DATAS; 将数据段的地址移到 `AX` 寄存器中。
MOV DS,AX; 将 `AX` 寄存器的值移到 `DS` 寄存器中，即将数据段的地址移到 `DS` 寄存器中。

MOV SI, OFFSET ARRAY; 将 `ARRAY` 变量的地址加载到 `SI` 寄存器中。
MOV CX, LENGTHOF ARRAY; 将 `ARRAY` 变量的长度加载到 `CX` 寄存器中。

MOV AL, [SI]; 将数组的第一个元素的值加载到 `AL` 寄存器中，作为初始的最大值。
MOV AH, [SI]; 将数组的第一个元素的值加载到 `AH` 寄存器中，作为初始的最小值。

FINDMAX:; 标记查找最大值部分的起始位置。
CMP AL, [SI]; 比较当前元素与最大值的大小关系。
JC UPDATEMAX; 如果当前元素大于最大值，则跳转到UPDATEMAX标签处更新最大值。

FINDMIN:; 标记查找最小值部分的起始位置。
CMP [SI], AH; 比较当前元素与最小值的大小关系。
JC UPDATEMIN; 如果当前元素小于最小值，则跳转到UPDATEMIN标签处更新最小值。

NEXT:; 标记循环继续执行的位置。
INC SI; 递增 `SI` 寄存器，指向下一个字符。
LOOP FINDMAX; 循环执行查找过程，直到处理完所有字符。

UPDATEMAX:; 标记更新最大值部分的起始位置。
MOV AL, [SI]; 将当前元素的值加载到 `AL` 寄存器中，更新最大值。

UPDATEMIN:; 标记更新最小值部分的起始位置。
MOV AH, [SI]; 将当前元素的值加载到 `AH` 寄存器中，更新最小值。

MOV [MIN], AH; 将找到的最小值存入 `MIN` 变量中。
MOV [MAX], AL; 将找到的最大值存入 `MAX` 变量中。

MOV DL,[MIN]; 将找到的最小值加载到 `DL` 寄存器中。
MOV AH,02H; 设置 `AH` 寄存器的值为02H，选择DOS中断的02H子功能，即输出字符。
INT 21H; 调用DOS中断，输出最小值。

MOV DL,20H; 将空格字符（ASCII码为20H）加载到 `DL` 寄存器中。
MOV AH,02H; 设置 `AH` 寄存器的值为02H，选择DOS中断的02H子功能，即输出字符。
INT 21H; 调用DOS中断，输出空格字符。

MOV DL,[MAX]; 将找到的最大值加载到 `DL` 寄存器中。
MOV AH,02H; 设置 `AH` 寄存器的值为02H，选择DOS中断的02H子功能，即输出字符。
INT 21H; 调用DOS中断，输出最大值。

MOV AH,4CH; 设置 `AH` 寄存器的值为4CH，选择DOS中断的4CH子功能，即结束程序。
INT 21H; 调用DOS中断，结束程序。

CODES ENDS; 结束代码段定义。
END START; 指定程序入口点为START标签处。```
```















```asm
DATAS SEGMENT; 定义数据段。
ARRAY DB 31H, 36H, 33H, 32H, 38H, 37H, 35H, '$'; 定义一个字节数组，包含值 31H、36H、33H、32H、38H、37H、35H 和 '$'。
TARGET DB 8 DUP(?); 定义一个字节数组，包含8个未初始化的元素。
DATAS ENDS; 结束数据段定义。

STACKS SEGMENT; 定义堆栈段。
STACKS ENDS; 结束堆栈段定义。

CODES SEGMENT; 定义代码段。
ASSUME CS:CODES,DS:DATAS,SS:STACKS; 使用 `ASSUME` 指令指定各个寄存器的值。
START:; 标记程序的起始位置。
MOV AX,DATAS; 将数据段的地址移到 `AX` 寄存器中。
MOV DS,AX; 将 `AX` 寄存器的值移到 `DS` 寄存器中，即将数据段的地址移到 `DS` 寄存器中。

MOV SI, OFFSET ARRAY; 将 `ARRAY` 变量的地址加载到 `SI` 寄存器中。
MOV DI, OFFSET TARGET; 将 `TARGET` 变量的地址加载到 `DI` 寄存器中。
MOV CX, LENGTHOF ARRAY; 将 `ARRAY` 变量的长度加载到 `CX` 寄存器中。

COPY_LOOP:; 标记循环部分的起始位置。
MOV AL, [SI]; 将 `SI` 寄存器指向的内存单元（即当前字符）的值加载到 `AL` 寄存器中。
MOV [DI], AL; 将 `AL` 寄存器的值（即当前字符）存入 `DI` 寄存器指向的内存单元（即目标数组）中。
INC SI; 递增 `SI` 寄存器，指向下一个字符。
INC DI; 递增 `DI` 寄存器，指向目标数组的下一个位置。
LOOP COPY_LOOP; 循环执行复制过程，直到处理完所有字符。

LEA DX,TARGET ; 使用 `LEA` 指令将 `TARGET` 变量的地址加载到 `DX` 寄存器中。
MOV AH,09H; 设置 `AH` 寄存器的值为09H，选择DOS中断的09H子功能，即输出字符串。
INT 21H; 调用DOS中断，输出目标数组。

MOV AH,4CH; 设置 `AH` 寄存器的值为4CH，选择DOS中断的4CH子功能，即结束程序。
INT 21H; 调用DOS中断，结束程序。

CODES ENDS; 结束代码段定义。
END START; 指定程序入口点为START标签处。```
```



ex3

```asm
DATAS SEGMENT
    ;此处输入数据段代码  
    
    ARRAY DB 31H, 36H, 33H, 32H, 38H, 37H, 35H, '$'
    TARGET DB 8 DUP(?)
    
DATAS ENDS

STACKS SEGMENT
    ;此处输入堆栈段代码
STACKS ENDS

CODES SEGMENT
    ASSUME CS:CODES,DS:DATAS,SS:STACKS
START:
    MOV AX,DATAS
    MOV DS,AX
    ;此处输入代码段代码
    
    MOV SI, OFFSET ARRAY
    MOV DI, OFFSET TARGET
    MOV CX, LENGTHOF ARRAY
    MOV AL, [SI]
    
COPY_LOOP:
    MOV AL, [SI]
    MOV [DI], AL
    INC SI
    INC DI
    LOOP COPY_LOOP
	
	LEA DX,TARGET 
	MOV AH,09H
	INT 21H
    
    MOV AH,4CH
    INT 21H
CODES ENDS
    END START
```



```asm
DATAS SEGMENT; 定义数据段。
ARRAY DB 31H, 36H, 33H, 32H, 38H, 37H, 35H, '$'; 定义一个字节数组，包含值 31H、36H、33H、32H、38H、37H、35H 和 '$'。
TARGET DB 8 DUP(?); 定义一个字节数组，包含8个未初始化的元素。
DATAS ENDS; 结束数据段定义。

STACKS SEGMENT; 定义堆栈段。
STACKS ENDS; 结束堆栈段定义。

CODES SEGMENT; 定义代码段。
ASSUME CS:CODES,DS:DATAS,SS:STACKS; 使用 `ASSUME` 指令指定各个寄存器的值。
START:; 标记程序的起始位置。
MOV AX,DATAS; 将数据段的地址移到 `AX` 寄存器中。
MOV DS,AX; 将 `AX` 寄存器的值移到 `DS` 寄存器中，即将数据段的地址移到 `DS` 寄存器中。

MOV SI, OFFSET ARRAY; 将 `ARRAY` 变量的地址加载到 `SI` 寄存器中。
MOV DI, OFFSET TARGET; 将 `TARGET` 变量的地址加载到 `DI` 寄存器中。
MOV CX, LENGTHOF ARRAY; 将 `ARRAY` 变量的长度加载到 `CX` 寄存器中。

COPY_LOOP:; 标记循环部分的起始位置。
MOV AL, [SI]; 将 `SI` 寄存器指向的内存单元（即当前字符）的值加载到 `AL` 寄存器中。
MOV [DI], AL; 将 `AL` 寄存器的值（即当前字符）存入 `DI` 寄存器指向的内存单元（即目标数组）中。
INC SI; 递增 `SI` 寄存器，指向下一个字符。
INC DI; 递增 `DI` 寄存器，指向目标数组的下一个位置。
LOOP COPY_LOOP; 循环执行复制过程，直到处理完所有字符。

LEA DX,TARGET ; 使用 `LEA` 指令将 `TARGET` 变量的地址加载到 `DX` 寄存器中。
MOV AH,09H; 设置 `AH` 寄存器的值为09H，选择DOS中断的09H子功能，即输出字符串。
INT 21H; 调用DOS中断，输出目标数组。

MOV AH,4CH; 设置 `AH` 寄存器的值为4CH，选择DOS中断的4CH子功能，即结束程序。
INT 21H; 调用DOS中断，结束程序。

CODES ENDS; 结束代码段定义。
END START; 指定程序入口点为START标签处。```
```





### 实验三

学习逻辑运算指令和移位指令的用法

 ![image-20230504201509619](%E6%B1%87%E7%BC%96.assets/image-20230504201509619.png)

 

实验要求

•写出源程序 

•对程序执行结果进行分析

请用一句代码一句解释然后换行的格式输出以上对所有代码的解释







ex1

这是一段用x86汇编语言写的代码。它定义了三个段：数据段、堆栈段和代码段。

在数据段中，定义了三个变量：
- `TEXT` 是一个字节数组，包含字符串 'Hello World!' 后跟一个 '$' 字符。
- `KEY` 是一个字节数组，包含值 125、248、16、8 和 26。
- `CRLF` 是一个字节数组，包含值 13、10 和 '$'。

在堆栈段中，没有定义任何内容。

在代码段中，首先使用 `ASSUME` 指令指定各个寄存器的值。然后，将数据段的地址移到 `DS` 寄存器中。接下来，使用 `LEA` 指令将 `TEXT` 变量的地址加载到 `DX` 寄存器中，并使用 `INT 21H` 调用DOS中断来输出字符串。

接下来，使用 `LEA` 指令将 `CRLF` 变量的地址加载到 `DX` 寄存器中，并使用 `INT 21H` 调用DOS中断来输出换行符。

然后，程序进入加密部分。首先，将 `TEXT` 和 `KEY` 变量的地址分别加载到 `SI` 和 `DI` 寄存器中，并将 `TEXT` 变量的长度加载到 `CX` 寄存器中。然后，使用循环对每个字符进行加密。在循环内部，使用 `XOR` 指令对字符进行异或运算，并将结果存回原位置。然后，递增指针并检查是否到达密钥的末尾。如果是，则将指针重置为密钥的开头。

加密完成后，程序进入解密部分。解密过程与加密过程类似，只是最后输出解密后的字符串。

最后，使用 `INT 21H` 调用DOS中断来结束程序。



`CRLF` 是一个字节数组，包含值 13、10 和 '$'。这个数组用于在DOS环境中输出换行符。在DOS环境中，换行符由两个字符组成：回车符（ASCII码为13）和换行符（ASCII码为10）。因此，这个数组包含了这两个字符的ASCII码值。最后一个字符 

 是DOS中断09H子功能的字符串结束标记。

在这段代码中，`CRLF` 变量被用于在输出字符串后输出一个换行符。具体来说，在代码段中，使用 `LEA` 指令将 `CRLF` 变量的地址加载到 `DX` 寄存器中，并使用 `INT 21H` 调用DOS中断来输出换行符。

````asm
```
DATAS SEGMENT: 定义数据段。
TEXT DB 'Hello World!','$': 定义一个字节数组，包含字符串 'Hello World!' 后跟一个 '$' 字符。
KEY DB 125, 248, 16, 8, 26: 定义一个字节数组，包含值 125、248、16、8 和 26。
CRLF DB 13, 10, '$': 定义一个字节数组，包含值 13、10 和 '$'。
DATAS ENDS: 结束数据段定义。

STACKS SEGMENT: 定义堆栈段。
STACKS ENDS: 结束堆栈段定义。

CODES SEGMENT: 定义代码段。
ASSUME CS:CODES,DS:DATAS,SS:STACKS: 使用 `ASSUME` 指令指定各个寄存器的值。
START:: 标记程序的起始位置。
MOV AX,DATAS: 将数据段的地址移到 `AX` 寄存器中。
MOV DS,AX: 将 `AX` 寄存器的值移到 `DS` 寄存器中，即将数据段的地址移到 `DS` 寄存器中。
LEA DX,TEXT: 使用 `LEA` 指令将 `TEXT` 变量的地址加载到 `DX` 寄存器中。
MOV AH,09H: 设置 `AH` 寄存器的值为09H，选择DOS中断的09H子功能，即输出字符串。
INT 21H: 调用DOS中断，输出字符串。

LEA DX,CRLF: 使用 `LEA` 指令将 `CRLF` 变量的地址加载到 `DX` 寄存器中。
MOV AH,09H: 设置 `AH` 寄存器的值为09H，选择DOS中断的09H子功能，即输出字符串。
INT 21H: 调用DOS中断，输出换行符。

MOV SI, OFFSET TEXT: 将 `TEXT` 变量的地址加载到 `SI` 寄存器中。
MOV DI, OFFSET KEY: 将 `KEY` 变量的地址加载到 `DI` 寄存器中。
MOV CX, LENGTHOF TEXT: 将 `TEXT` 变量的长度加载到 `CX` 寄存器中。
MOV BX, 0: 将 `BX` 寄存器清零。

ENCRYPT:: 标记加密部分的起始位置。
MOV AL, [SI]: 将 `SI` 寄存器指向的内存单元（即当前字符）的值加载到 `AL` 寄存器中。
XOR AL, [DI]: 使用 `XOR` 指令对 `AL` 寄存器和 `DI` 寄存器指向的内存单元（即当前密钥字符）进行异或运算。
MOV [SI], AL: 将异或运算的结果（即加密后的字符）存回原位置。
INC SI: 递增 `SI` 寄存器，指向下一个字符。
INC DI: 递增 `DI` 寄存器，指向下一个密钥字符。
INC BX: 递增 `BX` 寄存器，记录已处理的字符数。
CMP BX, LENGTHOF KEY: 比较 `BX` 和密钥长度，检查是否到达密钥末尾。
JL CONTINUE: 如果未到达密钥末尾，则跳转到CONTINUE标签处继续执行循环。
MOV BX, 0: 如果到达密钥末尾，则将 `BX` 清零。
MOV DI, OFFSET KEY: 将密钥的起始地址重新加载到 `DI` 寄存器中，重新开始使用密钥进行加密。

CONTINUE:: 标记循环继续执行的位置。
LOOP ENCRYPT: 循环执行加密过程，直到处理完所有字符。

MOV SI, OFFSET TEXT: 将 `TEXT` 变量的地址重新加载到 `SI寄存器中。
MOV DI, OFFSET KEY: 将 `KEY` 变量的地址重新加载到 `DI` 寄存器中。
MOV CX, LENGTHOF TEXT: 将 `TEXT` 变量的长度重新加载到 `CX` 寄存器中。
MOV BX, 0: 将 `BX` 寄存器清零。

LEA DX,TEXT: 使用 `LEA` 指令将 `TEXT` 变量的地址加载到 `DX` 寄存器中。
MOV AH,09H: 设置 `AH` 寄存器的值为09H，选择DOS中断的09H子功能，即输出字符串。
INT 21H: 调用DOS中断，输出加密后的字符串。

LEA DX,CRLF: 使用 `LEA` 指令将 `CRLF` 变量的地址加载到 `DX` 寄存器中。
MOV AH,09H: 设置 `AH` 寄存器的值为09H，选择DOS中断的09H子功能，即输出字符串。
INT 21H: 调用DOS中断，输出换行符。

DECRYPT:: 标记解密部分的起始位置。
MOV AL, [SI]: 将 `SI` 寄存器指向的内存单元（即当前字符）的值加载到 `AL` 寄存器中。
XOR AL, [DI]: 使用 `XOR` 指令对 `AL` 寄存器和 `DI` 寄存器指向的内存单元（即当前密钥字符）进行异或运算。
MOV [SI], AL: 将异或运算的结果（即解密后的字符）存回原位置。
INC SI: 递增 `SI` 寄存器，指向下一个字符。
INC DI: 递增 `DI` 寄存器，指向下一个密钥字符。
INC BX: 递增 `BX` 寄存器，记录已处理的字符数。
CMP BX, LENGTHOF KEY: 比较 `BX` 和密钥长度，检查是否到达密钥末尾。
JL CONTINUE2: 如果未到达密钥末尾，则跳转到CONTINUE2标签处继续执行循环。
MOV BX, 0: 如果到达密钥末尾，则将 `BX` 清零。
MOV DI, OFFSET KEY: 将密钥的起始地址重新加载到 `DI` 寄存器中，重新开始使用密钥进行解密。

CONTINUE2:: 标记循环继续执行的位置。
LOOP DECRYPT: 循环执行解密过程，直到处理完所有字符。

LEA DX, Text: 使用 `LEA` 指令将解密后的字符串加载到 `DX` 寄存器中。
MOV AH, 09H: 设置 `AH` 寄存器的值为09H，选择DOS中断的09H子功能，即输出字符串。
INT 21H: 调用DOS中断，输出解密后的字符串。

MOV AH,4CH: 设置 `AH` 寄存器的值为4CH，选择DOS中断的4CH子功能，即结束程序。
INT 21H: 调用DOS中断，结束程序。

CODES ENDS: 结束代码段定义。
END START: 指定程序入口点为START标签处。```
````



```asm
DATAS SEGMENT
    ;此处输入数据段代码  
    TEXT DB 'Hello World!','$' 
    KEY DB 125, 248, 16, 8, 26
    CRLF DB 13, 10, '$'
    
DATAS ENDS

STACKS SEGMENT
    ;此处输入堆栈段代码
STACKS ENDS

CODES SEGMENT
    ASSUME CS:CODES,DS:DATAS,SS:STACKS
START:
    MOV AX,DATAS
    MOV DS,AX
    ;此处输入代码段代码
    
    LEA DX,TEXT 
	MOV AH,09H
	INT 21H
	
    LEA DX,CRLF 
	MOV AH,09H
	INT 21H

	MOV SI, OFFSET TEXT
    MOV DI, OFFSET KEY
    MOV CX, LENGTHOF TEXT
	MOV BX, 0
	
ENCRYPT:
    MOV AL, [SI]
    XOR AL, [DI]
    MOV [SI], AL
    INC SI
    INC DI
    INC BX
    CMP BX, LENGTHOF KEY
    JL CONTINUE
    MOV BX, 0
    MOV DI, OFFSET KEY
    CONTINUE:
    LOOP ENCRYPT
    
    MOV SI, OFFSET TEXT
    MOV DI, OFFSET KEY
    MOV CX, LENGTHOF TEXT
	MOV BX, 0
	
	LEA DX,TEXT 
	MOV AH,09H
	INT 21H
	
	LEA DX,CRLF 
	MOV AH,09H
	INT 21H
    
DECRYPT:
    MOV AL, [SI]
    XOR AL, [DI]
    MOV [SI], AL
    INC SI
    INC DI
    INC BX
    CMP BX, LENGTHOF KEY
    JL CONTINUE2
    MOV BX, 0
    MOV DI, OFFSET KEY
    CONTINUE2:
    LOOP DECRYPT
    
    LEA DX, Text
    MOV AH, 09H
    INT 21H
    
    MOV AH,4CH
    INT 21H
CODES ENDS
    END START
```

ex2

```asm
DATAS SEGMENT
    ;此处输入数据段代码  
    
    TEXT DB 'Hello','$' 
    KEY DB -2, 2, 1, 0, -1
    CRLF DB 13, 10, '$'
    
DATAS ENDS

STACKS SEGMENT
    ;此处输入堆栈段代码
STACKS ENDS

CODES SEGMENT
    ASSUME CS:CODES,DS:DATAS,SS:STACKS
START:
    MOV AX,DATAS
    MOV DS,AX
    ;此处输入代码段代码
    
    LEA DX, Text
    MOV AH, 09H
    INT 21H
    
    LEA DX, CRLF
    MOV AH, 09H
    INT 21H

    ; 循环移位加密
   	MOV SI, OFFSET TEXT
    MOV DI, OFFSET KEY
    MOV CX, LENGTHOF TEXT
ENCRYPT:
    MOV AL, [SI]
    MOV DH, [DI]
    TEST DH, DH
    JZ NO_SHIFT
    JS LEFT_SHIFT
    ; 右移
    MOV BL, CL
    MOV CL, DH
    ROR AL, CL
    MOV CL, BL

    JMP CONTINUE_SHIFT
    
LEFT_SHIFT:
    ; 左移
    NEG DH
    MOV BL, CL
    MOV CL, DH
    ROL AL, CL
    MOV CL, BL
    JMP CONTINUE_SHIFT
    
NO_SHIFT:
    
CONTINUE_SHIFT:
    MOV [SI], AL
    INC SI
    INC DI
    LOOP ENCRYPT

    ; 显示密文
    LEA DX, Text
    MOV AH, 09H
    INT 21H
    
    LEA DX, CRLF
    MOV AH, 09H
    INT 21H

    ; 循环移位解密
    MOV SI, OFFSET TEXT
    MOV DI, OFFSET KEY
    MOV CX, LENGTHOF TEXT
    
DECRYPT:
    MOV AL, [SI]
    MOV DH, [DI]
    TEST DH, DH
    JZ NO_SHIFT2
    JS LEFT_SHIFT2
    ; 右移
    MOV BL, CL
    MOV CL, DH
    ROL AL, CL
    MOV CL, BL
    JMP CONTINUE_SHIFT2
    
LEFT_SHIFT2:
    ; 左移
    NEG DH
    MOV BL, CL
    MOV CL, DH
    ROR AL, CL
    MOV CL, BL
    JMP CONTINUE_SHIFT2

NO_SHIFT2:
    
CONTINUE_SHIFT2:
    MOV [SI], AL
    INC SI
    INC DI
    LOOP DECRYPT

    ; 显示解密后的明文
    LEA DX, [Text]
    MOV AH, 09H
    INT 21H
    
    MOV AH,4CH
    INT 21H
CODES ENDS
    END START
```



```asm
DATAS SEGMENT; 定义数据段。
TEXT DB 'Hello','$'; 定义一个字节数组，包含字符串 'Hello' 后跟一个 '$' 字符。
KEY DB -2, 2, 1, 0, -1; 定义一个字节数组，包含值 -2、2、1、0 和 -1。
CRLF DB 13, 10, '$'; 定义一个字节数组，包含值 13、10 和 '$'。
DATAS ENDS; 结束数据段定义。

STACKS SEGMENT; 定义堆栈段。
STACKS ENDS; 结束堆栈段定义。

CODES SEGMENT; 定义代码段。
ASSUME CS:CODES,DS:DATAS,SS:STACKS; 使用 `ASSUME` 指令指定各个寄存器的值。
START:; 标记程序的起始位置。
MOV AX,DATAS; 将数据段的地址移到 `AX` 寄存器中。
MOV DS,AX; 将 `AX` 寄存器的值移到 `DS` 寄存器中，即将数据段的地址移到 `DS` 寄存器中。

LEA DX, Text; 使用 `LEA` 指令将 `Text` 变量的地址加载到 `DX` 寄存器中。
MOV AH, 09H; 设置 `AH` 寄存器的值为09H，选择DOS中断的09H子功能，即输出字符串。
INT 21H; 调用DOS中断，输出字符串。

LEA DX, CRLF; 使用 `LEA` 指令将 `CRLF` 变量的地址加载到 `DX` 寄存器中。
MOV AH, 09H; 设置 `AH` 寄存器的值为09H，选择DOS中断的09H子功能，即输出字符串。
INT 21H; 调用DOS中断，输出换行符。

MOV SI, OFFSET TEXT; 将 `TEXT` 变量的地址加载到 `SI` 寄存器中。
MOV DI, OFFSET KEY; 将 `KEY` 变量的地址加载到 `DI` 寄存器中。
MOV CX, LENGTHOF TEXT; 将 `TEXT` 变量的长度加载到 `CX` 寄存器中。

ENCRYPT:; 标记加密部分的起始位置。
MOV AL, [SI]; 将 `SI` 寄存器指向的内存单元（即当前字符）的值加载到 `AL` 寄存器中。
MOV DH, [DI]; 将 `DI` 寄存器指向的内存单元（即当前密钥字符）的值加载到 `DH` 寄存器中。
TEST DH, DH; 测试 `DH` 寄存器是否为0。
JZ NO_SHIFT; 如果为0，则跳转到NO_SHIFT标签处继续执行。
JS LEFT_SHIFT; 如果为负数，则跳转到LEFT_SHIFT标签处进行左移操作。

ROR AL, CL; 使用 `ROR` 指令对 `AL` 寄存器进行循环右移操作，移动位数由 `CL` 寄存器指定。
MOV CL, BL; 将原来保存在 `BL` 寄存器中的循环计数恢复到 `CL` 寄存器中。

JMP CONTINUE_SHIFT; 跳转到CONTINUE_SHIFT标签处继续执行。

LEFT_SHIFT:; 标记左移操作部分的起始位置。
NEG DH; 对 `DH` 寄存器取相反数，得到左移位数。
MOV BL, CL; 将循环计数保存在 `BL` 寄存器中以备后用。
MOV CL, DH; 将左移位数加载到 `CL` 寄存器中。

ROL AL, CL; 使用 `ROL` 指令对 `AL` 寄存器进行循环左移操作，移动位数由 `CL` 寄存器指定。

JMP CONTINUE_SHIFT;

NO_SHIFT:;

CONTINUE_SHIFT:;
MOV [SI], AL;
INC SI;
INC DI;
LOOP ENCRYPT;

LEA DX, Text;
MOV AH, 09H;
INT 21H;

LEA DX, CRLF;
MOV AH, 09H; 设置 `AH` 寄存器的值为09H，选择DOS中断的09H子功能，即输出字符串。
INT 21H; 调用DOS中断，输出换行符。

MOV SI, OFFSET TEXT; 将 `TEXT` 变量的地址重新加载到 `SI` 寄存器中。
MOV DI, OFFSET KEY; 将 `KEY` 变量的地址重新加载到 `DI` 寄存器中。
MOV CX, LENGTHOF TEXT; 将 `TEXT` 变量的长度重新加载到 `CX` 寄存器中。

DECRYPT:; 标记解密部分的起始位置。
MOV AL, [SI]; 将 `SI` 寄存器指向的内存单元（即当前字符）的值加载到 `AL` 寄存器中。
MOV DH, [DI]; 将 `DI` 寄存器指向的内存单元（即当前密钥字符）的值加载到 `DH` 寄存器中。
TEST DH, DH; 测试 `DH` 寄存器是否为0。
JZ NO_SHIFT2; 如果为0，则跳转到NO_SHIFT2标签处继续执行。
JS LEFT_SHIFT2; 如果为负数，则跳转到LEFT_SHIFT2标签处进行左移操作。

ROL AL, CL; 使用 `ROL` 指令对 `AL` 寄存器进行循环左移操作，移动位数由 `CL` 寄存器指定。
MOV CL, BL; 将原来保存在 `BL` 寄存器中的循环计数恢复到 `CL` 寄存器中。

JMP CONTINUE_SHIFT2;

LEFT_SHIFT2:; 标记左移操作部分的起始位置。
NEG DH; 对 `DH` 寄存器取相反数，得到左移位数。
MOV BL, CL; 将循环计数保存在 `BL` 寄存器中以备后用。
MOV CL, DH; 将左移位数加载到 `CL` 寄存器中。

ROR AL, CL; 使用 `ROR` 指令对 `AL` 寄存器进行循环右移操作，移动位数由 `CL` 寄存器指定。

JMP CONTINUE_SHIFT2;

NO_SHIFT2:;

CONTINUE_SHIFT2:;
MOV [SI], AL;
INC SI;
INC DI;
LOOP DECRYPT;

LEA DX, Text;
MOV AH, 09H;
INT 21H;

MOV AH,4CH;
INT 21H;
CODES ENDS;
END START; 指定程序入口点为START标签处。```
```



>
>
>这段代码的主要思路是使用循环移位算法对一个字符串进行加密和解密。首先，在数据段中定义了一个名为 `TEXT` 的字符串，包含值 'Hello' 和 '$'。还定义了一个名为 `KEY` 的字节数组，包含值 -2、2、1、0 和 -1，用作加密和解密的密钥。另外，还定义了一个名为 `CRLF` 的字符串，包含值 13、10 和 '$'，用于输出换行符。
>
>在代码段中，首先使用 `ASSUME` 指令指定各个寄存器的值，并将数据段的地址移到 `DS` 寄存器中。然后，使用DOS中断09H子功能输出原始字符串和换行符。
>
>接下来，进入加密部分。首先将 `TEXT` 和 `KEY` 变量的地址分别加载到 `SI` 和 `DI` 寄存器中，并将 `TEXT` 变量的长度加载到 `CX` 寄存器中。然后进入一个循环，每次循环都根据密钥对当前字符进行循环移位操作。如果密钥字符为正数，则进行循环右移操作；如果密钥字符为负数，则进行循环左移操作；如果密钥字符为0，则不进行移位操作。循环执行直到处理完所有字符。
>
>在完成加密操作后，代码使用DOS中断09H子功能输出加密后的字符串和换行符。
>
>接下来，进入解密部分。解密部分的代码与加密部分类似，只是移位方向相反。在完成解密操作后，代码使用DOS中断09H子功能输出解密后的字符串。
>
>最后，使用DOS中断4CH子功能结束程序。
